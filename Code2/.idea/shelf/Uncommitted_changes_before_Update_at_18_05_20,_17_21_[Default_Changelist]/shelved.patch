Index: code-backend/src/main/java/com/swop/ProgramArea.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.*;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.*;\n\n/**\n * A program area that handles drops of blocks in it for constructing program(s).\n * It has no notion of position or width or height.\n */\npublic class ProgramArea implements PushBlocks {\n\n    private final int radius = 10;  // Radius for connections\n    /**\n     * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.\n     * Nested blocks (inside StatementBlocks) should be accessed using ''\n     */\n    private final List<Block> program = new LinkedList<>();\n    /**\n     * List recording all blocks currently present in program area\n     */\n    private final List<Block> allBlocks = new ArrayList<>();\n    private Block nextBlock;\n\n    /**\n     * @param b Point1\n     * @param p Point2\n     * @return Returns the distance between the two given points.\n     */\n    private static int getDistance(Point b, Point p) {\n        return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));\n    }\n\n    public List<Block> getAllBlocks() {\n        return allBlocks;\n    }\n\n    public List<Block> getProgram() {\n        return program;\n    }\n\n    public void dropBlockIn(Block draggedBlock, Point position) {\n        draggedBlock.setPosition(position);\n        dropBlock(draggedBlock);\n    }\n\n    public void dropBlock(Block draggedBlock) {\n        if (reasonToReset(draggedBlock)) return;\n\n        // 1) Handle Connection\n        handleConnections(draggedBlock);\n\n        // 2) Push program blocks if dragged block was added to a statement body\n        // TODO: fix this with some pattern to share information about the program\n        pushProgramBlocks(draggedBlock);\n\n        System.out.println(\"Program has \" + getProgram().size() + \" blocks !\");\n    }\n\n    // TODO: 11/05/2020 better name? \n    private boolean reasonToReset(Block draggedBlock) {\n        if (!allBlocks.contains(draggedBlock)) allBlocks.add(draggedBlock);\n        resetProgramExecution();\n        if (allBlocks.size() == 1) {\n            program.add(draggedBlock);\n            resetProgramExecution();\n            return true;\n        }\n        return false;\n    }\n\n    // TODO: 11/05/2020 Better name? \n    private void pushProgramBlocks(Block draggedBlock) {\n        if (draggedBlock.getParentStatement() != null) {\n            Block currentBlock = draggedBlock;\n            while (currentBlock.getParentStatement() != null) {\n                currentBlock = currentBlock.getParentStatement();\n            }\n            if (getProgram().contains(currentBlock)) {\n                // Now currentBlock is a block from the program\n                int distance = draggedBlock.getHeight() + draggedBlock.getStep();\n                if (draggedBlock instanceof StatementBlock) distance += ((StatementBlock) draggedBlock).getGapSize();\n                PushBlocks.pushFrom(getProgram(), getProgram().indexOf(currentBlock) + 1, distance);\n            }\n        }\n    }\n\n\n    /**\n     * Handle eventual connections of close blocks for the given draggedblock.\n     */\n    private void handleConnections(Block draggedBlock) {\n        if (!(draggedBlock instanceof ConditionBlock)) handleVerticalConnections(draggedBlock);\n        else handleHorizontalConnections(draggedBlock);\n    }\n\n    private void handleVerticalConnections(Block draggedBlock) {\n        assert !(draggedBlock instanceof ConditionBlock);\n        Block closeBlock;\n        // 1) plug\n        closeBlock = getBlockWithPlugForBlockWithinRadius(draggedBlock, radius);\n        if (closeBlock != null) {\n            plug(draggedBlock, closeBlock);\n        } else {\n            // 2) socket\n            closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                socket(draggedBlock, closeBlock);\n                draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n            } else {\n                // 3) statement body\n                closeBlock = getStatementBlockBodyPlugWithinRadius(draggedBlock, radius);\n                if (closeBlock != null) {\n                    draggedBlock.setPosition(((StatementBlock) closeBlock).getBodyPlugPosition());\n                    ((StatementBlock) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);\n                }\n            }\n        }\n    }\n\n    // TODO: 11/05/2020 Better name?\n    private void plug(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockAfter(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentStatement() != null) {\n            closeBlock.getParentStatement().addBodyBlockAfter(draggedBlock, closeBlock);\n        }\n        draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n    }\n\n    // TODO: 11/05/2020 better name?\n    private void socket(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockBefore(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentStatement() != null) {\n            closeBlock.getParentStatement().addBodyBlockBefore(draggedBlock, closeBlock);\n        }\n    }\n\n    private void handleHorizontalConnections(Block draggedBlock) {\n        assert draggedBlock instanceof ConditionBlock;\n        Block closeBlock;\n        closeBlock = getStatementBlockConditionPlugWithinRadius(draggedBlock, radius);\n        if (closeBlock != null) {\n            draggedBlock.setPosition(((StatementBlock) closeBlock).getConditionPlugPosition());\n            ((StatementBlock) closeBlock).addConditionBlock((ConditionBlock) draggedBlock);\n        } else {\n            closeBlock = getConditionBlockConditionPlugWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                draggedBlock.setPosition(closeBlock.getPlugPosition());\n                StatementBlock parent = closeBlock.getParentStatement();\n                parent.addConditionBlock((ConditionBlock) draggedBlock);\n            }\n        }\n    }\n\n    /**\n     * @return Returns the next to be executed block of the program.\n     */\n    public Block getNextBlock() {\n        return nextBlock;\n        // TODO: set the firstly added block as the next block and highlight it directly\n    }\n\n    /**\n     * Sets the next block to the next block in the list, otherwise to null.\n     */\n    public void setNextBlock() {\n        int i = program.indexOf(nextBlock);\n        if (i + 1 < program.size()) {\n            nextBlock = program.get(i + 1);\n        } else {\n            nextBlock = null;\n        }\n    }\n\n    /**\n     * @return returns the block at the given position (x,y) if that block exists otherwise null will be returned.\n     */\n    public Block getBlockAt(int x, int y) {\n        Optional<Block> found = getAllBlocks().stream().filter(block1 -> block1.isPositionOn(x, y)).findAny();\n        System.out.println(found);\n        return found.orElse(null);\n    }\n\n    /**\n     * @param draggedBlock block that is dragged\n     * @param closeBlock   closest block to the dragged block\n     * @return Returns the connection point if precondition is valid\n     * @pre Both blocks are close enough to each other for connection\n     */\n    public Point getConnectionPoint(Block draggedBlock, Block closeBlock) {\n        if (draggedBlock.isUnder(closeBlock)) return closeBlock.getPlugPosition();\n        else\n            return new Point(closeBlock.getSocketPosition().x, closeBlock.getSocketPosition().y - draggedBlock.getHeight() - 10);\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the block with plug that is within the given radius of the given block\n     */\n    private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || (block instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (block instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param uiBlock given block\n     * @param radius  given radius\n     * @return Returns the block with socket within the given radius of the given block\n     */\n    private Block getBlockWithSocketForBlockWithinRadius(Block uiBlock, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == uiBlock || (uiBlock instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (uiBlock instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            if (getDistance(uiBlock.getPlugPosition(), b.getSocketPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block body plug within the given radius of the given block\n     */\n    private Block getStatementBlockBodyPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getBodyPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block condition plug within the given radius of the given block\n     */\n    private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the condition block condition plug within the given radius of the given block\n     */\n    private Block getConditionBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof ConditionBlock))\n                continue;\n\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list after the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockAfter(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock) + 1);\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list before the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockBefore(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock));\n    }\n\n    private void insertProgramBlockAtIndex(Block block, int index) {\n        program.add(index, block);\n        int distance = block.getHeight() + block.getStep();\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index + 1, distance);\n    }\n\n    /**\n     * @param block given block\n     *              Remove the given block from the program of this program area.\n     *              This does not mean that the given block is removed or outside the PA.\n     * @pre getProgram().contains(block)\n     */\n    private void removeProgramBlock(Block block) {\n        assert getProgram().contains(block);\n        int index = program.indexOf(block);\n        program.remove(block);\n\n        int distance = -block.getHeight() - block.getStep();\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index, distance);\n        getProgram().remove(block);\n        allBlocks.remove(block);\n    }\n\n    /**\n     * Remove the clickedBlock from this program area\n     *\n     * @param clickedBlock block that's dragged\n     */\n    public void removeBlockFromPA(Block clickedBlock) {\n        if (!(clickedBlock instanceof ConditionBlock)) {\n            StatementBlock parentStatement = clickedBlock.getParentStatement();\n            if (parentStatement != null) {\n                pushUp(clickedBlock, parentStatement);\n            }\n        } else {\n            clickedBlock.getParentStatement().removeConditionBlock((ConditionBlock) clickedBlock);\n        }\n        allBlocks.remove(clickedBlock);\n        if (getProgram().contains(clickedBlock)) {\n            removeProgramBlock(clickedBlock);\n        }\n    }\n\n    // TODO: 11/05/2020 better name?\n    private void pushUp(Block clickedBlock, StatementBlock parentStatement) {\n        // 1) Remove the body and push all superior body-blocks up\n        parentStatement.removeBodyBlock(clickedBlock);\n        // 2) Push program up\n        // 2.1) Find most superior program block\n        while (parentStatement.getParentStatement() != null) {\n            parentStatement = parentStatement.getParentStatement();\n        }\n        // 2.2) Push\n        if (getProgram().contains(parentStatement)) {\n            int distance = -clickedBlock.getHeight() - clickedBlock.getStep();\n            if (clickedBlock instanceof StatementBlock)\n                distance -= ((StatementBlock) clickedBlock).getGapSize();\n            PushBlocks.pushFrom(program, program.indexOf(parentStatement) + 1, distance);\n        }\n    }\n\n    /**\n     * Resets the program area, first block will be current block\n     */\n    public void resetProgramExecution() {\n        for (Block block : getProgram()) {\n            if (block instanceof StatementBlock) {\n                ((StatementBlock) block).resetExecution();\n            }\n        }\n\n        if (!program.isEmpty()) nextBlock = ((LinkedList<Block>) program).getFirst();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/ProgramArea.java	(revision 6a3a27ba6cdffd9fb1d94828509772ef77800a4b)
+++ code-backend/src/main/java/com/swop/ProgramArea.java	(date 1589814542903)
@@ -53,7 +53,6 @@
         handleConnections(draggedBlock);
 
         // 2) Push program blocks if dragged block was added to a statement body
-        // TODO: fix this with some pattern to share information about the program
         pushProgramBlocks(draggedBlock);
 
         System.out.println("Program has " + getProgram().size() + " blocks !");
@@ -347,7 +346,8 @@
                 pushUp(clickedBlock, parentStatement);
             }
         } else {
-            clickedBlock.getParentStatement().removeConditionBlock((ConditionBlock) clickedBlock);
+            if (clickedBlock.getParentStatement() != null)
+                clickedBlock.getParentStatement().removeConditionBlock((ConditionBlock) clickedBlock);
         }
         allBlocks.remove(clickedBlock);
         if (getProgram().contains(clickedBlock)) {
Index: code-backend/src/main/java/com/swop/blocks/StatementBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\nimport com.swop.BlockrGame;\nimport com.swop.Predicate;\nimport com.swop.PushBlocks;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class StatementBlock extends Block implements Executable, VerticallyConnectable {\n    private final int pillarWidth = 10;\n    protected List<ConditionBlock> conditions = new ArrayList<>();\n    protected List<Block> bodyBlocks = new ArrayList<>();\n    protected Block currentBodyBlock = null;\n    protected Block current = null;\n    private int gapSize;\n    private final int conditionWidth;\n    private boolean Busy;\n    private boolean done = false;\n\n    public StatementBlock(Point position, int width, int height) {\n        super(position, width, height);\n        conditionWidth = width / 2;\n        executeType = ExecuteType.NonWorldChanging;\n\n    }\n\n    @Override\n    public void setPreviousDropPosition(Point previousDropPosition) {\n        super.setPreviousDropPosition(previousDropPosition);\n        for (Block bodyBlock : getBodyBlocks()) {\n            bodyBlock.setPreviousDropPosition(bodyBlock.getPosition());\n        }\n        for (Block condition : getConditions()) {\n            condition.setPreviousDropPosition(condition.getPosition());\n        }\n    }\n\n    public boolean isBusy() {\n        return Busy;\n    }\n\n    public void setBusy(boolean busy) {\n        Busy = busy;\n    }\n\n    public Block getCurrent() {\n        return current;\n    }\n\n    public void setCurrent(Block current) {\n        this.current = current;\n    }\n\n    protected void setNextCurrent() {\n        if (getCurrent() == null && !getBodyBlocks().isEmpty()) {\n            setCurrent(getBodyBlocks().get(0));\n        } else {\n            try {\n                setCurrent(getBodyBlocks().get(getBodyBlocks().indexOf(current) + 1));\n            } catch (Exception e) {\n                setCurrent(null);\n            }\n        }\n    }\n\n    public void resetExecution() {\n        setCurrent(null);\n        setBusy(false);\n        setDone(false);\n    }\n\n    @Override\n    public void setPosition(Point position) {\n        try {\n            int dx = position.x - getPosition().x;\n            int dy = position.y - getPosition().y;\n            super.setPosition(position);\n            for (Block bodyBlock : getBodyBlocks()) {\n                bodyBlock.setPosition(new Point(bodyBlock.getPosition().x + dx, bodyBlock.getPosition().y + dy));\n            }\n            for (Block conditionBlock : getConditions()) {\n                conditionBlock.setPosition(new Point(conditionBlock.getPosition().x + dx, conditionBlock.getPosition().y + dy));\n            }\n        } catch (NullPointerException e) {\n            super.setPosition(position);\n        }\n    }\n\n    public boolean isConditionValid() throws IllegalStateException {\n        if (conditions.isEmpty()) throw new IllegalStateException(\"No condition for the statement\");\n\n        int size = conditions.size();\n        ConditionBlock last = conditions.get(size - 1);\n        // Predicate(that isn't NOT) should only be at the last (and has to)\n        for (int i = 0; i < size; i++) {\n            if (conditions.get(i).isPredicate() && i < size - 1) {\n                throw new IllegalStateException(\"Invalid condition for statement block\");\n            }\n        }\n\n\n        // if length is even then there is an odd number of not blocks -> opposite of the result of wallInFront(world)\n        if (conditions.size() % 2 == 0) return !getGameWorld().evaluate(last.getPredicate());\n        else return getGameWorld().evaluate(last.getPredicate());\n\n    }\n\n    @Override\n    public void execute() {\n    }\n\n\n    public List<Block> getBodyBlocks() {\n        return bodyBlocks;\n    }\n\n    @Override\n    public boolean isDone() {\n        return done;\n    }\n\n    @Override\n    public void setDone(boolean done) {\n        this.done = done;\n    }\n\n    public List<ConditionBlock> getConditions() {\n        return conditions;\n    }\n\n    /**\n     * 1) Add the given block after the given existing block\n     * 2) And push all others inside the body\n     * 3) And make all the parents' gap sizes bigger.\n     * <p>\n     * If existing block is null add the given block at the start of the body\n     */\n    public void addBodyBlockAfter(Block block, Block existingBlock) {\n        if (existingBlock == null) throw new IllegalArgumentException();\n        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();\n        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock) + 1);\n\n    }\n\n    /**\n     * Add the given block before the given existing block.\n     */\n    public void addBodyBlockBefore(Block block, Block existingBlock) {\n        if (existingBlock == null) throw new IllegalArgumentException();\n        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();\n        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock));\n    }\n\n    public void insertBodyBlockAtIndex(Block block, int index) {\n        // 1) Add to the body blocks of this statement\n        bodyBlocks.add(index, block);\n        block.setParentStatement(this);\n\n        // 2) Push all next body blocks down\n        int distance = block.getHeight() + step;\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(bodyBlocks, index + 1, distance);\n\n        // 3) Increase the gap of this statement and all eventual superior parent statements\n        StatementBlock currentParent = block.getParentStatement();\n        while (currentParent != null) {\n            currentParent.increaseGapSize(distance);\n            currentParent = currentParent.getParentStatement();\n        }\n    }\n\n    /**\n     * @pre bodyBlocks.contains(block)\n     */\n    public void removeBodyBlock(Block block) {\n        assert bodyBlocks.contains(block);\n\n        int index = bodyBlocks.indexOf(block);\n        bodyBlocks.remove(block);\n        int distance = -block.getHeight() - step;\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(bodyBlocks, index, distance);\n\n        block.setParentStatement(null);\n\n        StatementBlock currentParent = this;\n        while (currentParent != null) {\n            currentParent.increaseGapSize(distance);\n            currentParent = currentParent.getParentStatement();\n        }\n    }\n\n    public void addConditionBlock(ConditionBlock block) {\n        conditions.add(block);\n        block.setParentStatement(this);\n    }\n\n    public void removeConditionBlock(ConditionBlock block) {\n        assert getConditions().contains(block);\n\n        ConditionBlock currentCondition;\n        int n = getConditions().size();\n        int j = getConditions().indexOf(block);\n        for (int i = n - 1; i >= j; i--) {\n            currentCondition = getConditions().get(i);\n            currentCondition.setParentStatement(null);\n            conditions.remove(currentCondition);\n        }\n    }\n\n    @Override\n    public Point getPlugPosition() {\n        return new Point(getPosition().x /*+ step * 3*/, getPosition().y + getHeight() + /*pillarWidth*/ +gapSize + step);\n    }\n\n    @Override\n    public Point getSocketPosition() {\n        return new Point(getPosition().x /*+ step * 3*/, getPosition().y + step);\n    }\n\n    public Point getBodyPlugPosition() {\n        return new Point(getPosition().x + pillarWidth, getPosition().y + getHeight() - step);\n    }\n\n    public Point getConditionPlugPosition() {\n        return new Point(getPosition().x + conditionWidth + step, getPosition().y);\n    }\n\n    public int getGapSize() {\n        return gapSize;\n    }\n\n    public void setGapSize(int gapSize) {\n        this.gapSize = gapSize;\n    }\n\n    public void increaseGapSize(int increase) {\n        this.setGapSize(getGapSize() + increase);\n    }\n\n    /**\n     * Is the given position on this statement block.\n     * This method is overridden bcs statementblocks should only be clicked on their upper part (conditionWidth).\n     */\n    @Override\n    public boolean isPositionOn(int x, int y) {\n        return (x > getPosition().x && x < getPosition().x + conditionWidth) && (y > getPosition().y && y < getPosition().y + getHeight());\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/StatementBlock.java	(revision 6a3a27ba6cdffd9fb1d94828509772ef77800a4b)
+++ code-backend/src/main/java/com/swop/blocks/StatementBlock.java	(date 1589815220751)
@@ -88,8 +88,10 @@
         }
     }
 
-    public boolean isConditionValid() throws IllegalStateException {
-        if (conditions.isEmpty()) throw new IllegalStateException("No condition for the statement");
+    public boolean isConditionValid() {
+        // TODO: decide whether to return false or throw exceptions on illegal conditions
+
+        if (conditions.isEmpty()) return false;
 
         int size = conditions.size();
         ConditionBlock last = conditions.get(size - 1);
@@ -100,10 +102,10 @@
             }
         }
 
-
         // if length is even then there is an odd number of not blocks -> opposite of the result of wallInFront(world)
         if (conditions.size() % 2 == 0) return !getGameWorld().evaluate(last.getPredicate());
-        else return getGameWorld().evaluate(last.getPredicate());
+        else if (last.isPredicate()) return getGameWorld().evaluate(last.getPredicate());
+        else return false;
 
     }
 
Index: code-backend/src/main/java/com/swop/BlockrGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.Block;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.command.DeleteBlockCommand;\nimport com.swop.command.DropBlockCommand;\nimport com.swop.command.ExecuteCommand;\nimport com.swop.command.ICommand;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class BlockrGame {\n    private final static AtomicReference<BlockrGame> instance = new AtomicReference<>();\n    private final ProgramArea programArea;\n    private final GameWorldType gameWorldType;\n    /**\n     * Maximum number of blocks that can be used\n     */\n    private final int maxBlocks;\n    private GameWorld gameWorld;\n    /**\n     * Stack for all the undo's\n     */\n    private final Stack<ICommand> undoStack = new Stack<>();\n    /**\n     * Stack for all the redo's\n     */\n    private final Stack<ICommand> redoStack = new Stack<>();\n\n    /**\n     * Initializes BlockrGame\n     *\n     * @param maxBlocks     maximum number of blocks that can be used.\n     * @param gameWorldType given type of gameWorld\n     */\n    public BlockrGame(int maxBlocks, GameWorldType gameWorldType) {\n        this.maxBlocks = maxBlocks;\n        this.programArea = new ProgramArea();\n        this.gameWorldType = gameWorldType;\n        this.gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns program that is currently in program area\n     */\n    public List<Block> getProgram() {\n        return programArea.getProgram();\n    }\n\n    public ProgramArea getProgramArea() {\n        return programArea;\n    }\n\n    /**\n     * @param block Given block\n     * @return Returns the position of the given block\n     */\n    public Point getBlockPosition(Block block) {\n        return block.getPosition();\n    }\n\n    /**\n     * Adds block to Program Area\n     *\n     * @param block given block\n     */\n    public void dropBlockInPA(Block block) {\n        if (block == null) throw new IllegalArgumentException();\n        executeCommand(new DropBlockCommand(programArea, block));\n    }\n\n    /**\n     * Removes block from Program Area\n     *\n     * @param draggedBlock given block\n     * @param isRelease    Boolean recording whether this is a release (outside PA) or not (a click)\n     */\n    public void removeBlockFromPA(Block draggedBlock, boolean isRelease) {\n        if (isRelease) {\n            executeCommand(new DeleteBlockCommand(programArea, draggedBlock));\n        } else {\n            programArea.removeBlockFromPA(draggedBlock);\n        }\n    }\n\n    /**\n     * Executes next block\n     */\n    public void executeNext() {\n        if (programArea.getNextBlock() != null) {\n            executeCommand(new ExecuteCommand(gameWorld, programArea.getNextBlock()));\n            if (programArea.getNextBlock().isDone()) {\n                programArea.setNextBlock();\n\n            }\n        } else {\n            resetEverything();\n        }\n    }\n\n    public Block getNextToBeExecutedBlock() {\n        // TODO: fix this method for highlight\n        if (programArea.getNextBlock() instanceof StatementBlock) {\n            StatementBlock statementBlock = (StatementBlock) programArea.getNextBlock();\n\n            if (((StatementBlock) programArea.getNextBlock()).getCurrent() != null) {\n                return statementBlock.getCurrent();\n            } else if (statementBlock.isConditionValid()) {\n                return statementBlock.getBodyBlocks().get(0);\n            }\n        }\n        return programArea.getNextBlock();\n    }\n\n    /**\n     * Resets the game world and the program area\n     */\n    public void resetEverything() {\n        programArea.resetProgramExecution();\n        gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns the number of blocks that are in the Program Area\n     */\n    public int getNumBlocksInPA() {\n        return programArea.getAllBlocks().size();\n    }\n\n    public int getNumBlocksInProgram() {\n        int count = 0;\n        for (Block block : getProgram()) {\n            if (block instanceof StatementBlock) {\n                count += ((StatementBlock) block).getBodyBlocks().size() + ((StatementBlock) block).getConditions().size();\n            }\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * @return Returns all the blocks that are in the Program Area\n     */\n    public List<Block> getAllBlocksInPA() {\n        return programArea.getAllBlocks();\n    }\n\n    /**\n     * position of a block is (x,y)\n     *\n     * @param x x-value of position\n     * @param y y-value of position\n     * @return returns a block if there is one at the given position otherwise null will be returned.\n     */\n    public Block getBlockInPaAt(int x, int y) {\n        return programArea.getBlockAt(x, y);\n    }\n\n    /**\n     * @return Returns true if the number of blocks in the program area is equal or greater than the maximum number of blocks\n     */\n    public boolean isPaletteHidden() {\n        return (maxBlocks - getNumBlocksInPA()) <= 0;\n    }\n\n    /**\n     * @return Returns the game world\n     */\n    public GameWorld getGameWorld() {\n        return gameWorld;\n    }\n\n    /**\n     * @return Returns the game world type\n     */\n    public GameWorldType getGameWorldType() {\n        return gameWorldType;\n    }\n\n    /**\n     * undoes the previous operation if there is one otherwise nothing will be done\n     */\n    public void undoCommand() {\n        if (!undoStack.isEmpty()) {\n            ICommand command = undoStack.pop();\n            command.undo();\n            redoStack.add(command);\n        }\n    }\n\n    /**\n     * redoes the previous undone operation if an operation is undone otherwise nothing happens\n     */\n    public void redoCommand() {\n        if (!redoStack.isEmpty()) {\n            executeCommand(redoStack.pop());\n        }\n    }\n\n    /**\n     * Given command will be executed\n     *\n     * @param command given command\n     */\n    public void executeCommand(ICommand command) {\n        command.execute();\n        undoStack.add(command);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/BlockrGame.java	(revision 6a3a27ba6cdffd9fb1d94828509772ef77800a4b)
+++ code-backend/src/main/java/com/swop/BlockrGame.java	(date 1589815277639)
@@ -108,7 +108,7 @@
 
             if (((StatementBlock) programArea.getNextBlock()).getCurrent() != null) {
                 return statementBlock.getCurrent();
-            } else if (statementBlock.isConditionValid()) {
+            } else if (statementBlock.isConditionValid() && !statementBlock.getBodyBlocks().isEmpty()) {
                 return statementBlock.getBodyBlocks().get(0);
             }
         }
