Index: code-backend/src/main/java/com/swop/ProgramArea.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.*;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * A program area that handles drops of blocks in it for constructing program(s).\n * It has no notion of position or width or height.\n */\npublic class ProgramArea implements PushBlocks {\n\n    private final int radius = 10;  // Radius for connections\n    /**\n     * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.\n     * Nested blocks (inside StatementBlocks) should be accessed using ''\n     */\n    private final List<Block> program = new LinkedList<>();\n    /**\n     * List recording all blocks currently present in program area\n     */\n    private final List<Block> allBlocks = new ArrayList<>();\n    private Block nextBlock;\n\n    /**\n     * @param b Point1\n     * @param p Point2\n     * @return Returns the distance between the two given points.\n     */\n    private static int getDistance(Point b, Point p) {\n        return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));\n    }\n\n    public List<Block> getAllBlocks() {\n        return allBlocks;\n    }\n\n    public List<Block> getProgram() {\n        return program;\n    }\n\n    public void dropBlockIn(Block draggedBlock, Point position) {\n        draggedBlock.setPosition(position);\n        dropBlock(draggedBlock);\n    }\n\n    public void dropBlock(Block draggedBlock) {\n        if (allBlocks.size() == 0) {\n            allBlocks.add(draggedBlock);\n            program.add(draggedBlock);\n            nextBlock = draggedBlock;\n            return;\n        } else if (!allBlocks.contains(draggedBlock)) allBlocks.add(draggedBlock);\n\n        // 1) Handle Connection\n        handleConnections(draggedBlock);\n\n        // 2) Push program blocks if dragged block was added to a statement body\n        pushProgramBlocksForBody(draggedBlock);\n\n        // 3) Reset program execution (and adjust next block)\n        resetProgramExecution();\n\n        System.out.println(\"Program has \" + getProgram().size() + \" blocks !\");\n    }\n\n    /**\n     * Push program blocks if the given dragged block was added to a statement body\n     */\n    private void pushProgramBlocksForBody(Block draggedBlock) {\n        if (draggedBlock.getParentBlock() != null) {\n\n            Block currentBlock = draggedBlock;\n            while (currentBlock.getParentBlock() != null) {\n                currentBlock = currentBlock.getParentBlock();\n            }\n            if (getProgram().contains(currentBlock)) {\n                // Now currentBlock is a block from the program\n                int distance = draggedBlock.getHeight() + draggedBlock.getStep();\n                if (draggedBlock instanceof StatementBlock) distance += ((StatementBlock) draggedBlock).getGapSize();\n                PushBlocks.pushFrom(getProgram(), getProgram().indexOf(currentBlock) + 1, distance);\n            }\n        }\n    }\n\n\n    /**\n     * Handle eventual connections of close blocks for the given draggedblock.\n     */\n    private void handleConnections(Block draggedBlock) {\n        if (!(draggedBlock instanceof ConditionBlock)) handleVerticalConnections(draggedBlock);\n        else handleHorizontalConnections(draggedBlock);\n    }\n\n    private void handleVerticalConnections(Block draggedBlock) {\n        assert !(draggedBlock instanceof ConditionBlock);\n        Block closeBlock;\n        // 1) plug\n        closeBlock = getBlockWithPlugForBlockWithinRadius(draggedBlock, radius);\n        if (closeBlock != null) {\n            plug(draggedBlock, closeBlock);\n        } else {\n            // 2) socket\n            closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                socket(draggedBlock, closeBlock);\n                draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n            } else {\n                // 3) statement body\n                closeBlock = getStatementBlockBodyPlugWithinRadius(draggedBlock, radius);\n                if (closeBlock != null) {\n                    draggedBlock.setPosition(((StatementBlock) closeBlock).getBodyPlugPosition());\n                    ((StatementBlock) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);\n                }\n            }\n        }\n    }\n\n    // TODO: 11/05/2020 Better name?\n    private void plug(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockAfter(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentBlock() != null) {\n            closeBlock.getParentBlock().addBodyBlockAfter(draggedBlock, closeBlock);\n        }\n        draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n    }\n\n    // TODO: 11/05/2020 better name?\n    private void socket(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockBefore(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentBlock() != null) {\n            closeBlock.getParentBlock().addBodyBlockBefore(draggedBlock, closeBlock);\n        }\n    }\n\n    private void handleHorizontalConnections(Block draggedBlock) {\n        assert draggedBlock instanceof ConditionBlock;\n        Block closeBlock;\n        closeBlock = getStatementBlockConditionPlugWithinRadius(draggedBlock, radius);\n        if (closeBlock != null) {\n            draggedBlock.setPosition(((StatementBlock) closeBlock).getConditionPlugPosition());\n            ((StatementBlock) closeBlock).addConditionBlock((ConditionBlock) draggedBlock);\n        } else {\n            closeBlock = getConditionBlockConditionPlugWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                draggedBlock.setPosition(closeBlock.getPlugPosition());\n                StatementBlock parent = closeBlock.getParentBlock();\n                parent.addConditionBlock((ConditionBlock) draggedBlock);\n            }\n        }\n    }\n\n    /**\n     * @return Returns the next to be executed block of the program.\n     */\n    public Block getNextBlock() {\n        return nextBlock;\n    }\n\n    /**\n     * Sets the next block to the next block in the list, otherwise to null.\n     */\n    public void setNextBlock() {\n        int i = program.indexOf(nextBlock);\n        if (i + 1 < program.size()) {\n            nextBlock = program.get(i + 1);\n        } else {\n            nextBlock = null;\n        }\n    }\n\n    /**\n     * @return returns the block at the given position (x,y) if that block exists otherwise null will be returned.\n     */\n    public Block getBlockAt(int x, int y) {\n        Optional<Block> found = getAllBlocks().stream().filter(block1 -> block1.isPositionOn(x, y)).findAny();\n        System.out.println(found);\n        return found.orElse(null);\n    }\n\n    /**\n     * @param draggedBlock block that is dragged\n     * @param closeBlock   closest block to the dragged block\n     * @return Returns the connection point if precondition is valid\n     * @pre Both blocks are close enough to each other for connection\n     */\n    public Point getConnectionPoint(Block draggedBlock, Block closeBlock) {\n        if (draggedBlock.isUnder(closeBlock)) return closeBlock.getPlugPosition();\n        else\n            return new Point(closeBlock.getSocketPosition().x, closeBlock.getSocketPosition().y - draggedBlock.getHeight() - 10);\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the block with plug that is within the given radius of the given block\n     */\n    private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || (block instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (block instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param uiBlock given block\n     * @param radius  given radius\n     * @return Returns the block with socket within the given radius of the given block\n     */\n    private Block getBlockWithSocketForBlockWithinRadius(Block uiBlock, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == uiBlock || (uiBlock instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (uiBlock instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            if (getDistance(uiBlock.getPlugPosition(), b.getSocketPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block body plug within the given radius of the given block\n     */\n    private Block getStatementBlockBodyPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getBodyPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block condition plug within the given radius of the given block\n     */\n    private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the condition block condition plug within the given radius of the given block\n     */\n    private Block getConditionBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof ConditionBlock))\n                continue;\n\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list after the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockAfter(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock) + 1);\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list before the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockBefore(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock));\n    }\n\n    private void insertProgramBlockAtIndex(Block block, int index) {\n        program.add(index, block);\n        int distance = block.getHeight() + block.getStep();\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index + 1, distance);\n    }\n\n    /**\n     * @param block given block\n     *              Remove the given block from the program of this program area.\n     *              This does not mean that the given block is removed or outside the PA.\n     * @pre getProgram().contains(block)\n     */\n    private void removeProgramBlock(Block block) {\n        assert getProgram().contains(block);\n        int index = program.indexOf(block);\n        program.remove(block);\n\n        int distance = -block.getHeight() - block.getStep();\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index, distance);\n        getProgram().remove(block);\n        allBlocks.remove(block);\n    }\n\n    /**\n     * Remove the clickedBlock from this program area\n     *\n     * @param clickedBlock block that's dragged\n     */\n    public void removeBlockFromPA(Block clickedBlock) {\n        if (!(clickedBlock instanceof ConditionBlock)) {\n            StatementBlock parentStatement = clickedBlock.getParentBlock();\n            if (parentStatement != null) {\n                pushUpBodyAndProgramAfterClickOn(parentStatement, clickedBlock);\n            }\n        } else {\n            if (clickedBlock.getParentBlock() != null)\n                clickedBlock.getParentBlock().removeConditionBlock((ConditionBlock) clickedBlock);\n        }\n        allBlocks.remove(clickedBlock);\n        if (getProgram().contains(clickedBlock)) {\n            removeProgramBlock(clickedBlock);\n        }\n    }\n\n    /**\n     * Push up the body of the given parentStatement and the program due to a click on the given clicked block.\n     * @param clickedBlock\n     * @param parentStatement\n     */\n    private void pushUpBodyAndProgramAfterClickOn(StatementBlock parentStatement, Block clickedBlock) {\n        // 1) Remove the body and push all superior body-blocks up\n        parentStatement.removeBodyBlock(clickedBlock);\n        // 2) Push program up\n        // 2.1) Find most superior program block\n        while (parentStatement.getParentBlock() != null) {\n            parentStatement = parentStatement.getParentBlock();\n        }\n        // 2.2) Push\n        if (getProgram().contains(parentStatement)) {\n            int distance = -clickedBlock.getHeight() - clickedBlock.getStep();\n            if (clickedBlock instanceof StatementBlock)\n                distance -= ((StatementBlock) clickedBlock).getGapSize();\n            PushBlocks.pushFrom(program, program.indexOf(parentStatement) + 1, distance);\n        }\n    }\n\n    /**\n     * Resets the program area, first block will be current block.\n     */\n    public void resetProgramExecution() {\n        for (Block block : getProgram()) if (block instanceof StatementBlock) ((StatementBlock) block).resetExecution();\n        if (!program.isEmpty()) nextBlock = ((LinkedList<Block>) program).getFirst();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/ProgramArea.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/ProgramArea.java	(date 1589904587292)
@@ -81,7 +81,7 @@
             if (getProgram().contains(currentBlock)) {
                 // Now currentBlock is a block from the program
                 int distance = draggedBlock.getHeight() + draggedBlock.getStep();
-                if (draggedBlock instanceof StatementBlock) distance += ((StatementBlock) draggedBlock).getGapSize();
+                if (draggedBlock instanceof BlockWithBody) distance += ((BlockWithBody) draggedBlock).getGapSize();
                 PushBlocks.pushFrom(getProgram(), getProgram().indexOf(currentBlock) + 1, distance);
             }
         }
@@ -108,13 +108,13 @@
             closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);
             if (closeBlock != null) {
                 socket(draggedBlock, closeBlock);
-                draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));
+                draggedBlock.setPosition(getVerticalConnectionPoint(draggedBlock, closeBlock));
             } else {
                 // 3) statement body
-                closeBlock = getStatementBlockBodyPlugWithinRadius(draggedBlock, radius);
+                closeBlock = getBlockWithBodyPlugWithinRadius(draggedBlock, radius);
                 if (closeBlock != null) {
-                    draggedBlock.setPosition(((StatementBlock) closeBlock).getBodyPlugPosition());
-                    ((StatementBlock) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);
+                    draggedBlock.setPosition(((BlockWithBody) closeBlock).getBodyPlugPosition());
+                    ((BlockWithBody) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);
                 }
             }
         }
@@ -127,7 +127,7 @@
         } else if (closeBlock.getParentBlock() != null) {
             closeBlock.getParentBlock().addBodyBlockAfter(draggedBlock, closeBlock);
         }
-        draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));
+        draggedBlock.setPosition(getVerticalConnectionPoint(draggedBlock, closeBlock));
     }
 
     // TODO: 11/05/2020 better name?
@@ -149,8 +149,8 @@
         } else {
             closeBlock = getConditionBlockConditionPlugWithinRadius(draggedBlock, radius);
             if (closeBlock != null) {
-                draggedBlock.setPosition(closeBlock.getPlugPosition());
-                StatementBlock parent = closeBlock.getParentBlock();
+                draggedBlock.setPosition(((HorizontallyConnectable) closeBlock).getPlugPosition());
+                StatementBlock parent = (StatementBlock) closeBlock.getParentBlock();
                 parent.addConditionBlock((ConditionBlock) draggedBlock);
             }
         }
@@ -190,10 +190,14 @@
      * @return Returns the connection point if precondition is valid
      * @pre Both blocks are close enough to each other for connection
      */
-    public Point getConnectionPoint(Block draggedBlock, Block closeBlock) {
-        if (draggedBlock.isUnder(closeBlock)) return closeBlock.getPlugPosition();
+    private Point getVerticalConnectionPoint(Block draggedBlock, Block closeBlock) {
+        if (!(draggedBlock instanceof VerticallyConnectable && closeBlock instanceof VerticallyConnectable))
+            throw new IllegalArgumentException("Not both blocks are vertically connectable");
+
+        if (draggedBlock.isUnder(closeBlock)) return ((VerticallyConnectable) closeBlock).getPlugPosition();
         else
-            return new Point(closeBlock.getSocketPosition().x, closeBlock.getSocketPosition().y - draggedBlock.getHeight() - 10);
+            return new Point(((VerticallyConnectable) closeBlock).getSocketPosition().x,
+                    ((VerticallyConnectable) closeBlock).getSocketPosition().y - draggedBlock.getHeight() - 10);
     }
 
     /**
@@ -203,31 +207,38 @@
      */
     private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {
         for (Block b : getAllBlocks()) {
-            if (b == block || (block instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))
-                    || (block instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))
-                continue;
+            if (b == block) continue;
 
-            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {
-                return b;
+            if (b instanceof HorizontallyConnectable && block instanceof HorizontallyConnectable) {
+                if (getDistance(((HorizontallyConnectable) block).getSocketPosition(), ((HorizontallyConnectable) b).getPlugPosition()) <= radius) {
+                    return b;
+                }
+            } else if (b instanceof VerticallyConnectable && block instanceof VerticallyConnectable) {
+                if (getDistance(((VerticallyConnectable) block).getSocketPosition(), ((VerticallyConnectable) b).getPlugPosition()) <= radius) {
+                    return b;
+                }
             }
-
         }
         return null;
     }
 
     /**
-     * @param uiBlock given block
-     * @param radius  given radius
+     * @param block  given block
+     * @param radius given radius
      * @return Returns the block with socket within the given radius of the given block
      */
-    private Block getBlockWithSocketForBlockWithinRadius(Block uiBlock, int radius) {
+    private Block getBlockWithSocketForBlockWithinRadius(Block block, int radius) {
         for (Block b : getAllBlocks()) {
-            if (b == uiBlock || (uiBlock instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))
-                    || (uiBlock instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))
-                continue;
+            if (b == block) continue;
 
-            if (getDistance(uiBlock.getPlugPosition(), b.getSocketPosition()) <= radius) {
-                return b;
+            if (b instanceof HorizontallyConnectable && block instanceof HorizontallyConnectable) {
+                if (getDistance(((HorizontallyConnectable) block).getPlugPosition(), ((HorizontallyConnectable) b).getSocketPosition()) <= radius) {
+                    return b;
+                }
+            } else if (b instanceof VerticallyConnectable && block instanceof VerticallyConnectable) {
+                if (getDistance(((VerticallyConnectable) block).getPlugPosition(), ((VerticallyConnectable) b).getSocketPosition()) <= radius) {
+                    return b;
+                }
             }
 
         }
@@ -239,12 +250,14 @@
      * @param radius given radius
      * @return Returns the statement block body plug within the given radius of the given block
      */
-    private Block getStatementBlockBodyPlugWithinRadius(Block block, int radius) {
+    private Block getBlockWithBodyPlugWithinRadius(Block block, int radius) {
+        if (!(block instanceof VerticallyConnectable))
+            throw new IllegalArgumentException("Block is not vertically connectable");
         for (Block b : getAllBlocks()) {
-            if (b == block || !(b instanceof StatementBlock) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)
+            if (b == block || !(b instanceof BlockWithBody) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)
                 continue;
 
-            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getBodyPlugPosition()) <= radius) {
+            if (getDistance(((VerticallyConnectable) block).getSocketPosition(), ((BlockWithBody) b).getBodyPlugPosition()) <= radius) {
                 return b;
             }
         }
@@ -257,11 +270,13 @@
      * @return Returns the statement block condition plug within the given radius of the given block
      */
     private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {
+        if (!(block instanceof HorizontallyConnectable))
+            throw new IllegalArgumentException("Block is not horizontally connectable");
         for (Block b : getAllBlocks()) {
             if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())
                 continue;
 
-            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {
+            if (getDistance(((HorizontallyConnectable) block).getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {
                 return b;
             }
         }
@@ -274,11 +289,12 @@
      * @return Returns the condition block condition plug within the given radius of the given block
      */
     private Block getConditionBlockConditionPlugWithinRadius(Block block, int radius) {
+        if (!(block instanceof ConditionBlock)) throw new IllegalArgumentException();
         for (Block b : getAllBlocks()) {
             if (b == block || !(b instanceof ConditionBlock))
                 continue;
 
-            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {
+            if (getDistance(((ConditionBlock) block).getSocketPosition(), ((ConditionBlock) b).getPlugPosition()) <= radius) {
                 return b;
             }
         }
@@ -341,13 +357,12 @@
      */
     public void removeBlockFromPA(Block clickedBlock) {
         if (!(clickedBlock instanceof ConditionBlock)) {
-            StatementBlock parentStatement = clickedBlock.getParentBlock();
-            if (parentStatement != null) {
-                pushUpBodyAndProgramAfterClickOn(parentStatement, clickedBlock);
+            BlockWithBody parentBlock = clickedBlock.getParentBlock();
+            if (parentBlock != null) {
+                pushUpBodyAndProgramAfterClickOn(parentBlock, clickedBlock);
             }
-        } else {
-            if (clickedBlock.getParentBlock() != null)
-                clickedBlock.getParentBlock().removeConditionBlock((ConditionBlock) clickedBlock);
+        } else if (clickedBlock.getParentBlock() != null) {
+            ((StatementBlock) clickedBlock.getParentBlock()).removeConditionBlock((ConditionBlock) clickedBlock);
         }
         allBlocks.remove(clickedBlock);
         if (getProgram().contains(clickedBlock)) {
@@ -356,24 +371,27 @@
     }
 
     /**
-     * Push up the body of the given parentStatement and the program due to a click on the given clicked block.
+     * Push up the body of the given parentBlock and the program due to a click on the given clicked block.
+     *
      * @param clickedBlock
-     * @param parentStatement
+     * @param parentBlock
      */
-    private void pushUpBodyAndProgramAfterClickOn(StatementBlock parentStatement, Block clickedBlock) {
+    private void pushUpBodyAndProgramAfterClickOn(BlockWithBody parentBlock, Block clickedBlock) {
+        // TODO: make sure it doesn't push program if the body belongs to a FunctionDefinitionBlock
+
         // 1) Remove the body and push all superior body-blocks up
-        parentStatement.removeBodyBlock(clickedBlock);
+        parentBlock.removeBodyBlock(clickedBlock);
         // 2) Push program up
         // 2.1) Find most superior program block
-        while (parentStatement.getParentBlock() != null) {
-            parentStatement = parentStatement.getParentBlock();
+        while (parentBlock.getParentBlock() != null) {
+            parentBlock = parentBlock.getParentBlock();
         }
         // 2.2) Push
-        if (getProgram().contains(parentStatement)) {
+        if (getProgram().contains(parentBlock)) {
             int distance = -clickedBlock.getHeight() - clickedBlock.getStep();
             if (clickedBlock instanceof StatementBlock)
                 distance -= ((StatementBlock) clickedBlock).getGapSize();
-            PushBlocks.pushFrom(program, program.indexOf(parentStatement) + 1, distance);
+            PushBlocks.pushFrom(program, program.indexOf(parentBlock) + 1, distance);
         }
     }
 
@@ -381,7 +399,7 @@
      * Resets the program area, first block will be current block.
      */
     public void resetProgramExecution() {
-        for (Block block : getProgram()) if (block instanceof StatementBlock) ((StatementBlock) block).resetExecution();
+        for (Block block : getAllBlocks()) if (block instanceof BlockWithBody) ((BlockWithBody) block).resetExecution();
         if (!program.isEmpty()) nextBlock = ((LinkedList<Block>) program).getFirst();
     }
 }
Index: code-backend/src/main/java/com/swop/blocks/Block.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\nimport com.swop.BlockrGame;\nimport com.swop.GameWorld;\n\nimport java.awt.*;\n\npublic abstract class Block implements Cloneable {\n    protected final int step;\n    private final int width;\n    private final int height;\n    protected ExecuteType executeType;\n    private StatementBlock parentBlock;\n    private BlockrGame blockrGame; // TODO: fix the BlockrGame dependency (I think it's not needed, see patterns)\n\n    private boolean busy = false;\n    private Point position;\n    private Point previousDropPosition;\n\n    protected Block(Point position, int width, int height) {\n        this.setPosition(position);\n        this.width = width;\n        this.height = height;\n        step = height / 6;\n    }\n\n    public Block clone() {\n        try {\n            return (Block) super.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public void setBlockrGame(BlockrGame blockrGame){\n        this.blockrGame = blockrGame;\n    }\n\n    public int getStep() {\n        return step;\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n    public boolean isBusy() {\n        return busy;\n    }\n\n    public void setBusy(boolean busy) {\n        this.busy = busy;\n    }\n\n    public ExecuteType getExecuteType() {\n        return executeType;\n    }\n\n    public StatementBlock getParentBlock() {\n        return parentBlock;\n    }\n\n    public void setParentBlock(StatementBlock parentBlock) {\n        this.parentBlock = parentBlock;\n    }\n\n    /**\n     * Check whether the given position is on this block.\n     */\n    public boolean isPositionOn(int x, int y) {\n        return (x > position.x && x < position.x + width) && (y > position.y && y < position.y + height);\n    }\n\n    /**\n     * Check whether this block is under the given block\n     */\n    public boolean isUnder(Block block) {\n        return this.getPosition().y > block.getPosition().y;\n    }\n\n    public Point getPosition() {\n        return position;\n    }\n\n    public void setPosition(Point position) {\n        if (position == null) throw new IllegalArgumentException();\n        this.position = position;\n    }\n\n    public Point getPreviousDropPosition() {\n        return previousDropPosition;\n    }\n\n    public void setPreviousDropPosition(Point previousDropPosition) {\n        this.previousDropPosition = previousDropPosition;\n    }\n\n    public GameWorld getGameWorld() {\n        if(blockrGame == null) throw new NullPointerException(\"BlockrGame not set in Block.\");\n        return blockrGame.getGameWorld();\n    }\n\n    public abstract Point getSocketPosition();\n\n    public abstract Point getPlugPosition();\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/Block.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/blocks/Block.java	(date 1589895841719)
@@ -10,7 +10,7 @@
     private final int width;
     private final int height;
     protected ExecuteType executeType;
-    private StatementBlock parentBlock;
+    private BlockWithBody parentBlock;
     private BlockrGame blockrGame; // TODO: fix the BlockrGame dependency (I think it's not needed, see patterns)
 
     private boolean busy = false;
@@ -61,11 +61,11 @@
         return executeType;
     }
 
-    public StatementBlock getParentBlock() {
+    public BlockWithBody getParentBlock() {
         return parentBlock;
     }
 
-    public void setParentBlock(StatementBlock parentBlock) {
+    public void setParentBlock(BlockWithBody parentBlock) {
         this.parentBlock = parentBlock;
     }
 
@@ -104,8 +104,4 @@
         if(blockrGame == null) throw new NullPointerException("BlockrGame not set in Block.");
         return blockrGame.getGameWorld();
     }
-
-    public abstract Point getSocketPosition();
-
-    public abstract Point getPlugPosition();
 }
Index: code-backend/src/main/java/com/swop/blocks/BlockWithBody.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class BlockWithBody extends Block{\n    protected List<Block> bodyBlocks = new ArrayList<>();\n    private Block nextBodyBlock = null;\n    private int gapSize;\n\n    protected BlockWithBody(Point position, int width, int height) {\n        super(position, width, height);\n    }\n\n    public Block getNextBodyBlock() {\n        return nextBodyBlock;\n    }\n\n    protected void setNextBodyBlock(Block nextBodyBlock) {\n        this.nextBodyBlock = nextBodyBlock;\n    }\n\n    protected void setNextBodyBlock() {\n        if (getNextBodyBlock() == null && !getBodyBlocks().isEmpty()) {\n            setNextBodyBlock(getBodyBlocks().get(0));\n        } else {\n            try {\n                setNextBodyBlock(getBodyBlocks().get(getBodyBlocks().indexOf(nextBodyBlock) + 1));\n            } catch (Exception e) {\n                setNextBodyBlock(null);\n            }\n        }\n    }\n\n    protected void executeNextBodyBlock() {\n        if (getNextBodyBlock() == null) {\n            setBusy(false);\n        } else {\n            Executable exBlock = (Executable) getNextBodyBlock();\n            exBlock.execute();\n            setNextBodyBlock();\n            if (getNextBodyBlock() == null) {\n                handleEndOfBody();\n            }\n        }\n    }\n\n    protected abstract void handleEndOfBody();\n\n    public List<Block> getBodyBlocks() {\n        return bodyBlocks;\n    }\n\n    public int getGapSize() {\n        return gapSize;\n    }\n\n    public void setGapSize(int gapSize) {\n        this.gapSize = gapSize;\n    }\n\n    public void increaseGapSize(int increase) {\n        this.setGapSize(getGapSize() + increase);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/BlockWithBody.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/blocks/BlockWithBody.java	(date 1589904759461)
@@ -1,5 +1,7 @@
 package com.swop.blocks;
 
+import com.swop.PushBlocks;
+
 import java.awt.*;
 import java.util.ArrayList;
 import java.util.List;
@@ -13,6 +15,75 @@
         super(position, width, height);
     }
 
+    /**
+     * 1) Add the given block after the given existing block
+     * 2) And push all others inside the body
+     * 3) And make all the parents' gap sizes bigger.
+     * <p>
+     * If existing block is null add the given block at the start of the body
+     */
+    public void addBodyBlockAfter(Block block, Block existingBlock) {
+        if (existingBlock == null) throw new IllegalArgumentException();
+        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();
+        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock) + 1);
+
+    }
+
+    /**
+     * Add the given block before the given existing block.
+     */
+    public void addBodyBlockBefore(Block block, Block existingBlock) {
+        if (existingBlock == null) throw new IllegalArgumentException();
+        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();
+        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock));
+    }
+
+    public void insertBodyBlockAtIndex(Block block, int index) {
+        // TODO: make sure program is not pushed for FunctionDefinitionBlock
+
+        // 1) Add to the body blocks of this statement
+        bodyBlocks.add(index, block);
+        block.setParentBlock(this);
+
+        // 2) Push all next body blocks down
+        int distance = block.getHeight() + step;
+        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();
+        PushBlocks.pushFrom(bodyBlocks, index + 1, distance);
+
+        // 3) Increase the gap of this statement and all eventual superior parent statements
+        BlockWithBody currentParent = block.getParentBlock();
+        while (currentParent != null) {
+            currentParent.increaseGapSize(distance);
+            currentParent = currentParent.getParentBlock();
+        }
+    }
+
+    /**
+     * @pre bodyBlocks.contains(block)
+     */
+    public void removeBodyBlock(Block block) {
+        assert bodyBlocks.contains(block);
+
+        int index = bodyBlocks.indexOf(block);
+        bodyBlocks.remove(block);
+        int distance = -block.getHeight() - step;
+        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();
+        PushBlocks.pushFrom(bodyBlocks, index, distance);
+
+        block.setParentBlock(null);
+
+        BlockWithBody currentParent = this;
+        while (currentParent != null) {
+            currentParent.increaseGapSize(distance);
+            currentParent = currentParent.getParentBlock();
+        }
+    }
+
+    public void resetExecution() {
+        setNextBodyBlock(null);
+        setBusy(false);
+    }
+
     public Block getNextBodyBlock() {
         return nextBodyBlock;
     }
@@ -52,6 +123,11 @@
         return bodyBlocks;
     }
 
+    public Point getBodyPlugPosition() {
+        int pillarWidth = 10;
+        return new Point(getPosition().x + pillarWidth, getPosition().y + getHeight() - step);
+    }
+
     public int getGapSize() {
         return gapSize;
     }
Index: code-backend/src/main/java/com/swop/blocks/StatementBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\nimport com.swop.PushBlocks;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class StatementBlock extends BlockWithBody implements Executable, VerticallyConnectable {\n    private final int pillarWidth = 10;\n    protected List<ConditionBlock> conditions = new ArrayList<>();\n    private final int conditionWidth;\n\n    public StatementBlock(Point position, int width, int height) {\n        super(position, width, height);\n        conditionWidth = width / 2;\n        executeType = ExecuteType.NonWorldChanging;\n    }\n\n    @Override\n    public void setPreviousDropPosition(Point previousDropPosition) {\n        super.setPreviousDropPosition(previousDropPosition);\n        for (Block bodyBlock : getBodyBlocks()) {\n            bodyBlock.setPreviousDropPosition(bodyBlock.getPosition());\n        }\n        for (Block condition : getConditions()) {\n            condition.setPreviousDropPosition(condition.getPosition());\n        }\n    }\n\n    public void resetExecution() {\n        setNextBodyBlock(null);\n        setBusy(false);\n    }\n\n    @Override\n    public void setPosition(Point position) {\n        try {\n            int dx = position.x - getPosition().x;\n            int dy = position.y - getPosition().y;\n            super.setPosition(position);\n            for (Block bodyBlock : getBodyBlocks()) {\n                bodyBlock.setPosition(new Point(bodyBlock.getPosition().x + dx, bodyBlock.getPosition().y + dy));\n            }\n            for (Block conditionBlock : getConditions()) {\n                conditionBlock.setPosition(new Point(conditionBlock.getPosition().x + dx, conditionBlock.getPosition().y + dy));\n            }\n        } catch (NullPointerException e) {\n            super.setPosition(position);\n        }\n    }\n\n    public boolean isConditionValid() {\n        // TODO: decide whether to return false or throw exceptions on illegal conditions\n\n        if (conditions.isEmpty()) return false;\n\n        int size = conditions.size();\n        ConditionBlock last = conditions.get(size - 1);\n        // Predicate(that isn't NOT) should only be at the last (and has to)\n        for (int i = 0; i < size; i++) {\n            if (conditions.get(i).isPredicate() && i < size - 1) {\n                throw new IllegalStateException(\"Invalid condition for statement block\");\n            }\n        }\n\n        // if length is even then there is an odd number of not blocks -> opposite of the result of wallInFront(world)\n        if (conditions.size() % 2 == 0) return !getGameWorld().evaluate(last.getPredicate());\n        else if (last.isPredicate()) return getGameWorld().evaluate(last.getPredicate());\n        else return false;\n\n    }\n\n    @Override\n    public void execute() {\n        if (isConditionValid() || isBusy()) {\n            if (!isBusy()) {\n                setBusy(true);\n                setNextBodyBlock();\n            }\n            executeNextBodyBlock();\n        } else {\n            setBusy(false);\n        }\n    }\n\n    public List<ConditionBlock> getConditions() {\n        return conditions;\n    }\n\n    /**\n     * 1) Add the given block after the given existing block\n     * 2) And push all others inside the body\n     * 3) And make all the parents' gap sizes bigger.\n     * <p>\n     * If existing block is null add the given block at the start of the body\n     */\n    public void addBodyBlockAfter(Block block, Block existingBlock) {\n        if (existingBlock == null) throw new IllegalArgumentException();\n        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();\n        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock) + 1);\n\n    }\n\n    /**\n     * Add the given block before the given existing block.\n     */\n    public void addBodyBlockBefore(Block block, Block existingBlock) {\n        if (existingBlock == null) throw new IllegalArgumentException();\n        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();\n        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock));\n    }\n\n    public void insertBodyBlockAtIndex(Block block, int index) {\n        // 1) Add to the body blocks of this statement\n        bodyBlocks.add(index, block);\n        block.setParentBlock(this);\n\n        // 2) Push all next body blocks down\n        int distance = block.getHeight() + step;\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(bodyBlocks, index + 1, distance);\n\n        // 3) Increase the gap of this statement and all eventual superior parent statements\n        StatementBlock currentParent = block.getParentBlock();\n        while (currentParent != null) {\n            currentParent.increaseGapSize(distance);\n            currentParent = currentParent.getParentBlock();\n        }\n    }\n\n    /**\n     * @pre bodyBlocks.contains(block)\n     */\n    public void removeBodyBlock(Block block) {\n        assert bodyBlocks.contains(block);\n\n        int index = bodyBlocks.indexOf(block);\n        bodyBlocks.remove(block);\n        int distance = -block.getHeight() - step;\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(bodyBlocks, index, distance);\n\n        block.setParentBlock(null);\n\n        StatementBlock currentParent = this;\n        while (currentParent != null) {\n            currentParent.increaseGapSize(distance);\n            currentParent = currentParent.getParentBlock();\n        }\n    }\n\n    public void addConditionBlock(ConditionBlock block) {\n        conditions.add(block);\n        block.setParentBlock(this);\n    }\n\n    public void removeConditionBlock(ConditionBlock block) {\n        assert getConditions().contains(block);\n\n        ConditionBlock currentCondition;\n        int n = getConditions().size();\n        int j = getConditions().indexOf(block);\n        for (int i = n - 1; i >= j; i--) {\n            currentCondition = getConditions().get(i);\n            currentCondition.setParentBlock(null);\n            conditions.remove(currentCondition);\n        }\n    }\n\n    @Override\n    public Point getPlugPosition() {\n        return new Point(getPosition().x /*+ step * 3*/, getPosition().y + getHeight() + /*pillarWidth*/ +getGapSize() + step);\n    }\n\n    @Override\n    public Point getSocketPosition() {\n        return new Point(getPosition().x /*+ step * 3*/, getPosition().y + step);\n    }\n\n    public Point getBodyPlugPosition() {\n        return new Point(getPosition().x + pillarWidth, getPosition().y + getHeight() - step);\n    }\n\n    public Point getConditionPlugPosition() {\n        return new Point(getPosition().x + conditionWidth + step, getPosition().y);\n    }\n\n    /**\n     * Is the given position on this statement block.\n     * This method is overridden bcs statementblocks should only be clicked on their upper part (conditionWidth).\n     */\n    @Override\n    public boolean isPositionOn(int x, int y) {\n        return (x > getPosition().x && x < getPosition().x + conditionWidth) && (y > getPosition().y && y < getPosition().y + getHeight());\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/StatementBlock.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/blocks/StatementBlock.java	(date 1589904759457)
@@ -1,13 +1,10 @@
 package com.swop.blocks;
 
-import com.swop.PushBlocks;
-
 import java.awt.*;
 import java.util.ArrayList;
 import java.util.List;
 
 public abstract class StatementBlock extends BlockWithBody implements Executable, VerticallyConnectable {
-    private final int pillarWidth = 10;
     protected List<ConditionBlock> conditions = new ArrayList<>();
     private final int conditionWidth;
 
@@ -28,11 +25,6 @@
         }
     }
 
-    public void resetExecution() {
-        setNextBodyBlock(null);
-        setBusy(false);
-    }
-
     @Override
     public void setPosition(Point position) {
         try {
@@ -88,68 +80,6 @@
         return conditions;
     }
 
-    /**
-     * 1) Add the given block after the given existing block
-     * 2) And push all others inside the body
-     * 3) And make all the parents' gap sizes bigger.
-     * <p>
-     * If existing block is null add the given block at the start of the body
-     */
-    public void addBodyBlockAfter(Block block, Block existingBlock) {
-        if (existingBlock == null) throw new IllegalArgumentException();
-        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();
-        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock) + 1);
-
-    }
-
-    /**
-     * Add the given block before the given existing block.
-     */
-    public void addBodyBlockBefore(Block block, Block existingBlock) {
-        if (existingBlock == null) throw new IllegalArgumentException();
-        if (!bodyBlocks.contains(existingBlock)) throw new IllegalArgumentException();
-        insertBodyBlockAtIndex(block, bodyBlocks.indexOf(existingBlock));
-    }
-
-    public void insertBodyBlockAtIndex(Block block, int index) {
-        // 1) Add to the body blocks of this statement
-        bodyBlocks.add(index, block);
-        block.setParentBlock(this);
-
-        // 2) Push all next body blocks down
-        int distance = block.getHeight() + step;
-        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();
-        PushBlocks.pushFrom(bodyBlocks, index + 1, distance);
-
-        // 3) Increase the gap of this statement and all eventual superior parent statements
-        StatementBlock currentParent = block.getParentBlock();
-        while (currentParent != null) {
-            currentParent.increaseGapSize(distance);
-            currentParent = currentParent.getParentBlock();
-        }
-    }
-
-    /**
-     * @pre bodyBlocks.contains(block)
-     */
-    public void removeBodyBlock(Block block) {
-        assert bodyBlocks.contains(block);
-
-        int index = bodyBlocks.indexOf(block);
-        bodyBlocks.remove(block);
-        int distance = -block.getHeight() - step;
-        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();
-        PushBlocks.pushFrom(bodyBlocks, index, distance);
-
-        block.setParentBlock(null);
-
-        StatementBlock currentParent = this;
-        while (currentParent != null) {
-            currentParent.increaseGapSize(distance);
-            currentParent = currentParent.getParentBlock();
-        }
-    }
-
     public void addConditionBlock(ConditionBlock block) {
         conditions.add(block);
         block.setParentBlock(this);
@@ -178,10 +108,6 @@
         return new Point(getPosition().x /*+ step * 3*/, getPosition().y + step);
     }
 
-    public Point getBodyPlugPosition() {
-        return new Point(getPosition().x + pillarWidth, getPosition().y + getHeight() - step);
-    }
-
     public Point getConditionPlugPosition() {
         return new Point(getPosition().x + conditionWidth + step, getPosition().y);
     }
Index: code-backend/src/main/java/com/swop/BlockrGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.Block;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.command.DeleteBlockCommand;\nimport com.swop.command.DropBlockCommand;\nimport com.swop.command.ExecuteCommand;\nimport com.swop.command.ICommand;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class BlockrGame {\n    private final static AtomicReference<BlockrGame> instance = new AtomicReference<>();\n    private final ProgramArea programArea;\n    private final GameWorldType gameWorldType;\n    /**\n     * Maximum number of blocks that can be used\n     */\n    private final int maxBlocks;\n    private GameWorld gameWorld;\n    /**\n     * Stack for all the undo's\n     */\n    private final Stack<ICommand> undoStack = new Stack<>();\n    /**\n     * Stack for all the redo's\n     */\n    private final Stack<ICommand> redoStack = new Stack<>();\n\n    /**\n     * Initializes BlockrGame\n     *\n     * @param maxBlocks     maximum number of blocks that can be used.\n     * @param gameWorldType given type of gameWorld\n     */\n    public BlockrGame(int maxBlocks, GameWorldType gameWorldType) {\n        this.maxBlocks = maxBlocks;\n        this.programArea = new ProgramArea();\n        this.gameWorldType = gameWorldType;\n        this.gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns program that is currently in program area\n     */\n    public List<Block> getProgram() {\n        return programArea.getProgram();\n    }\n\n    public ProgramArea getProgramArea() {\n        return programArea;\n    }\n\n    /**\n     * @param block Given block\n     * @return Returns the position of the given block\n     */\n    public Point getBlockPosition(Block block) {\n        return block.getPosition();\n    }\n\n    /**\n     * Adds block to Program Area\n     *\n     * @param block given block\n     */\n    public void dropBlockInPA(Block block) {\n        if (block == null) throw new IllegalArgumentException();\n        executeCommand(new DropBlockCommand(programArea, block));\n    }\n\n    /**\n     * Removes block from Program Area\n     *\n     * @param draggedBlock given block\n     * @param isRelease    Boolean recording whether this is a release (outside PA) or not (a click)\n     */\n    public void removeBlockFromPA(Block draggedBlock, boolean isRelease) {\n        if (isRelease) {\n            executeCommand(new DeleteBlockCommand(programArea, draggedBlock));\n        } else {\n            programArea.removeBlockFromPA(draggedBlock);\n        }\n    }\n\n    /**\n     * Executes next block\n     */\n    public void executeNext() {\n        if (programArea.getNextBlock() != null) {\n            executeCommand(new ExecuteCommand(gameWorld, programArea.getNextBlock()));\n            if (!programArea.getNextBlock().isBusy()) {\n                programArea.setNextBlock();\n            }\n        } else {\n            resetEverything();\n        }\n    }\n\n    public Block getNextToBeExecutedBlock() {\n        // TODO: fix this method for highlight\n        if (programArea.getNextBlock() instanceof StatementBlock) {\n            StatementBlock statementBlock = (StatementBlock) programArea.getNextBlock();\n\n            if (((StatementBlock) programArea.getNextBlock()).getNextBodyBlock() != null) {\n                return statementBlock.getNextBodyBlock();\n            } else if (statementBlock.isConditionValid() && !statementBlock.getBodyBlocks().isEmpty()) {\n                return statementBlock.getBodyBlocks().get(0);\n            }\n        }\n        return programArea.getNextBlock();\n    }\n\n    /**\n     * Resets the game world and the program area\n     */\n    public void resetEverything() {\n        programArea.resetProgramExecution();\n        gameWorld = gameWorldType.createNewInstance();\n        // TODO: fix this, no new instance, rather a reset pattern !\n    }\n\n    /**\n     * @return Returns the number of blocks that are in the Program Area\n     */\n    public int getNumBlocksInPA() {\n        return programArea.getAllBlocks().size();\n    }\n\n    public int getNumBlocksInProgram() {\n        int count = 0;\n        for (Block block : getProgram()) {\n            if (block instanceof StatementBlock) {\n                count += ((StatementBlock) block).getBodyBlocks().size() + ((StatementBlock) block).getConditions().size();\n            }\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * @return Returns all the blocks that are in the Program Area\n     */\n    public List<Block> getAllBlocksInPA() {\n        return programArea.getAllBlocks();\n    }\n\n    /**\n     * position of a block is (x,y)\n     *\n     * @param x x-value of position\n     * @param y y-value of position\n     * @return returns a block if there is one at the given position otherwise null will be returned.\n     */\n    public Block getBlockInPaAt(int x, int y) {\n        return programArea.getBlockAt(x, y);\n    }\n\n    /**\n     * @return Returns true if the number of blocks in the program area is equal or greater than the maximum number of blocks\n     */\n    public boolean isPaletteHidden() {\n        return (maxBlocks - getNumBlocksInPA()) <= 0;\n    }\n\n    /**\n     * @return Returns the game world\n     */\n    public GameWorld getGameWorld() {\n        return gameWorld;\n    }\n\n    /**\n     * @return Returns the game world type\n     */\n    public GameWorldType getGameWorldType() {\n        return gameWorldType;\n    }\n\n    /**\n     * undoes the previous operation if there is one otherwise nothing will be done\n     */\n    public void undoCommand() {\n        if (!undoStack.isEmpty()) {\n            ICommand command = undoStack.pop();\n            command.undo();\n            redoStack.add(command);\n        }\n    }\n\n    /**\n     * redoes the previous undone operation if an operation is undone otherwise nothing happens\n     */\n    public void redoCommand() {\n        if (!redoStack.isEmpty()) {\n            executeCommand(redoStack.pop());\n        }\n    }\n\n    /**\n     * Given command will be executed\n     *\n     * @param command given command\n     */\n    public void executeCommand(ICommand command) {\n        command.execute();\n        undoStack.add(command);\n        if (command instanceof DeleteBlockCommand || command instanceof DropBlockCommand) resetEverything();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/BlockrGame.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/BlockrGame.java	(date 1589905441355)
@@ -111,6 +111,7 @@
                 return statementBlock.getBodyBlocks().get(0);
             }
         }
+        // TODO: else if statement call block .. OR refactor
         return programArea.getNextBlock();
     }
 
@@ -131,6 +132,7 @@
     }
 
     public int getNumBlocksInProgram() {
+        // TODO: fix the count for nested statements (recursively !)
         int count = 0;
         for (Block block : getProgram()) {
             if (block instanceof StatementBlock) {
Index: code-frontend/src/main/java/com/swop/handlers/BlockrGameFacade.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.handlers;\n\nimport com.swop.*;\nimport com.swop.blocks.Block;\nimport com.swop.uiElements.UIBlock;\n\nimport java.util.Collection;\nimport java.util.List;\n\npublic class BlockrGameFacade {\n    DisplaceBlockHandler displaceBlockHandler;\n    ExecuteProgramHandler executeProgramHandler;\n    SharedData sharedData;\n\n    public BlockrGameFacade(SharedData sharedData){\n        this.sharedData = sharedData;\n        displaceBlockHandler = new DisplaceBlockHandler(sharedData);\n        executeProgramHandler = new ExecuteProgramHandler(sharedData);\n    }\n\n    public Collection<Action> getSupportedActions(){\n        return sharedData.getBlockrGame().getGameWorldType().getSupportedActions();\n    }\n\n    public Collection<Predicate> getSupportedPredicates(){\n        return sharedData.getBlockrGame().getGameWorldType().getSupportedPredicates();\n    }\n\n    public boolean isPaletteHidden(){\n        return sharedData.getBlockrGame().isPaletteHidden();\n    }\n\n    public List<UIBlock> getAllUIBlocksInPA(){\n        return displaceBlockHandler.getAllUIBlocksInPA();\n    }\n\n    public GameWorld getGameWorld(){\n        return sharedData.getBlockrGame().getGameWorld();\n    }\n\n    public int getNumBlocksInPA() {\n        return sharedData.getBlockrGame().getNumBlocksInPA();\n    }\n\n    public void handleProgramAreaForClickOn(UIBlock clickedBlock){\n        displaceBlockHandler.handleClickOn(clickedBlock);\n    }\n\n    public void handleReleaseInPA(UIBlock draggedBlock){\n        displaceBlockHandler.handleReleaseInPA(draggedBlock);\n    }\n\n    public void handleReleaseOutsidePA(UIBlock draggedBlock){\n        displaceBlockHandler.handleReleaseOutsidePA(draggedBlock);\n    }\n\n    public void adjustAllBlockPositions(){\n        sharedData.adjustAllBlockPositions();\n    }\n\n    public void adjustAllStatementBlockGaps(){\n        sharedData.adjustAllStatementBlockGaps();\n    }\n\n    public UIBlock getCorrespondingUiBlockFor(Block block){\n        return sharedData.getCorrespondingUiBlockFor(block);\n    }\n\n    public Block getBlockInPaAt(int x, int y){\n        return sharedData.getBlockrGame().getBlockInPaAt(x,y);\n    }\n\n    public void executeNext(){\n        executeProgramHandler.executeNext();\n    }\n\n    public void undo() {\n        sharedData.getBlockrGame().undoCommand();\n    }\n\n    public void redo() {\n        sharedData.getBlockrGame().redoCommand();\n    }\n\n    public void reset() {\n        sharedData.getBlockrGame().resetEverything();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/handlers/BlockrGameFacade.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-frontend/src/main/java/com/swop/handlers/BlockrGameFacade.java	(date 1589904759465)
@@ -59,7 +59,7 @@
     }
 
     public void adjustAllStatementBlockGaps(){
-        sharedData.adjustAllStatementBlockGaps();
+        sharedData.adjustAllBodyBlockGaps();
     }
 
     public UIBlock getCorrespondingUiBlockFor(Block block){
Index: code-backend/src/main/java/com/swop/blocks/FunctionDefinitionBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\npublic class FunctionDefinitionBlock {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/FunctionDefinitionBlock.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-backend/src/main/java/com/swop/blocks/FunctionDefinitionBlock.java	(date 1589895726689)
@@ -1,4 +1,15 @@
 package com.swop.blocks;
 
-public class FunctionDefinitionBlock {
+import java.awt.*;
+
+public class FunctionDefinitionBlock extends BlockWithBody{
+
+    protected FunctionDefinitionBlock(Point position, int width, int height) {
+        super(position, width, height);
+    }
+
+    @Override
+    protected void handleEndOfBody() {
+
+    }
 }
Index: code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.handlers;\n\nimport com.swop.BlockrGame;\nimport com.swop.blocks.Block;\nimport com.swop.blocks.ConditionBlock;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.uiElements.UIBlock;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DisplaceBlockHandler {\n    private final SharedData sharedData;\n\n    public DisplaceBlockHandler(SharedData sharedData) {\n        this.sharedData = sharedData;\n    }\n\n    /**\n     * @pre draggedBlock.getPosition() is inside the PA\n     */\n    public void handleReleaseInPA(UIBlock draggedBlock) {\n        // 1) Handle map\n        if (draggedBlock.getCorrespondingBlock() == null) {\n            draggedBlock.makeNewCorrespondingBlock();\n            draggedBlock.getCorrespondingBlock().setBlockrGame(sharedData.getBlockrGame());\n            sharedData.putInBlockUIBlockMap(draggedBlock.getCorrespondingBlock(), draggedBlock);\n        }\n\n        // 2) Handle drop position\n        Block backendBlock = draggedBlock.getCorrespondingBlock();\n        BlockrGame blockrGame = sharedData.getBlockrGame();\n        blockrGame.dropBlockInPA(backendBlock);\n        draggedBlock.setPosition(blockrGame.getBlockPosition(backendBlock));\n\n        // 3) Handle highlight\n        sharedData.setHighlightedBlock(sharedData.getCorrespondingUiBlockFor(blockrGame.getNextToBeExecutedBlock()));\n    }\n\n    public void handleReleaseOutsidePA(UIBlock draggedBlock) {\n        BlockrGame blockrGame = sharedData.getBlockrGame();\n        Block backendBlock = draggedBlock.getCorrespondingBlock();\n        if (backendBlock != null) {\n            // TODO: don't remove all bodies and conditions here, let the statementblock do it himself\n            // Remove all bodies and conditions as well from program area\n            if (backendBlock instanceof StatementBlock) {\n                List<Block> newBodyBlocks = new ArrayList<>(((StatementBlock) backendBlock).getBodyBlocks());\n                Collections.reverse(newBodyBlocks);  // Reversing is needed for correct undo\n                for (Block bodyBlock : newBodyBlocks) {\n                    blockrGame.removeBlockFromPA(bodyBlock, true);\n                }\n                List<ConditionBlock> newConditions = new ArrayList<>(((StatementBlock) backendBlock).getConditions());\n                Collections.reverse(newConditions);  // Reversing is needed for correct undo\n                for (Block condition : newConditions) {\n                    blockrGame.removeBlockFromPA(condition, true);\n                }\n            }\n            //remove the block from program area\n            blockrGame.removeBlockFromPA(backendBlock, true);\n        }\n\n        sharedData.setHighlightedBlock(sharedData.getCorrespondingUiBlockFor(blockrGame.getNextToBeExecutedBlock()));\n    }\n\n    public List<UIBlock> getAllUIBlocksInPA() {\n        List<Block> backBlocks = sharedData.getBlockrGame().getAllBlocksInPA();\n        List<UIBlock> returnUIBlocks = new ArrayList<>();\n        for (Block block : backBlocks) {\n            returnUIBlocks.add(sharedData.getCorrespondingUiBlockFor(block));\n        }\n        return returnUIBlocks;\n    }\n\n    public void handleClickOn(UIBlock clickedBlock) {\n        if (clickedBlock == null) throw new IllegalArgumentException();\n        Block backendBlock = clickedBlock.getCorrespondingBlock();\n        backendBlock.setPreviousDropPosition(backendBlock.getPosition());\n        sharedData.getBlockrGame().removeBlockFromPA(backendBlock, false);\n        sharedData.adjustAllBlockPositions();\n        sharedData.adjustAllStatementBlockGaps();\n        sharedData.setHighlightedBlock(sharedData.getCorrespondingUiBlockFor(sharedData.getBlockrGame().getNextToBeExecutedBlock()));\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(date 1589904759469)
@@ -2,6 +2,7 @@
 
 import com.swop.BlockrGame;
 import com.swop.blocks.Block;
+import com.swop.blocks.BlockWithBody;
 import com.swop.blocks.ConditionBlock;
 import com.swop.blocks.StatementBlock;
 import com.swop.uiElements.UIBlock;
@@ -44,16 +45,18 @@
         if (backendBlock != null) {
             // TODO: don't remove all bodies and conditions here, let the statementblock do it himself
             // Remove all bodies and conditions as well from program area
-            if (backendBlock instanceof StatementBlock) {
-                List<Block> newBodyBlocks = new ArrayList<>(((StatementBlock) backendBlock).getBodyBlocks());
+            if (backendBlock instanceof BlockWithBody) {
+                List<Block> newBodyBlocks = new ArrayList<>(((BlockWithBody) backendBlock).getBodyBlocks());
                 Collections.reverse(newBodyBlocks);  // Reversing is needed for correct undo
                 for (Block bodyBlock : newBodyBlocks) {
                     blockrGame.removeBlockFromPA(bodyBlock, true);
                 }
-                List<ConditionBlock> newConditions = new ArrayList<>(((StatementBlock) backendBlock).getConditions());
-                Collections.reverse(newConditions);  // Reversing is needed for correct undo
-                for (Block condition : newConditions) {
-                    blockrGame.removeBlockFromPA(condition, true);
+                if (backendBlock instanceof StatementBlock) {
+                    List<ConditionBlock> newConditions = new ArrayList<>(((StatementBlock) backendBlock).getConditions());
+                    Collections.reverse(newConditions);  // Reversing is needed for correct undo
+                    for (Block condition : newConditions) {
+                        blockrGame.removeBlockFromPA(condition, true);
+                    }
                 }
             }
             //remove the block from program area
@@ -78,7 +81,7 @@
         backendBlock.setPreviousDropPosition(backendBlock.getPosition());
         sharedData.getBlockrGame().removeBlockFromPA(backendBlock, false);
         sharedData.adjustAllBlockPositions();
-        sharedData.adjustAllStatementBlockGaps();
+        sharedData.adjustAllBodyBlockGaps();
         sharedData.setHighlightedBlock(sharedData.getCorrespondingUiBlockFor(sharedData.getBlockrGame().getNextToBeExecutedBlock()));
     }
 }
Index: code-frontend/src/main/java/com/swop/handlers/SharedData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.handlers;\n\nimport com.swop.BlockrGame;\nimport com.swop.GameWorldType;\nimport com.swop.blocks.Block;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.uiElements.UIBlock;\nimport com.swop.uiElements.UIStatementBlock;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Class holding information about all the shared objects between the existing handlers.\n * This class represents the \"database\" between frontend and backend.\n */\npublic class SharedData {\n    private static SharedData firstInstance = null;\n    private final BlockrGame blockrGame;\n    private final Map<Block, UIBlock> blockUIBlockMap = new HashMap<>();\n    private UIBlock highlightedBlock;\n\n    private SharedData(int maxBlocks, GameWorldType type) {\n        blockrGame = new BlockrGame(maxBlocks, type);\n    }\n\n    public static SharedData getInstance(int maxBlocks, GameWorldType type) {\n        if (firstInstance == null) {\n            firstInstance = new SharedData(maxBlocks, type);\n        }\n        return firstInstance;\n    }\n\n    public BlockrGame getBlockrGame() {\n        return blockrGame;\n    }\n\n    public void putInBlockUIBlockMap(Block key, UIBlock value) {\n        if (!blockUIBlockMap.containsKey(key)) {\n            blockUIBlockMap.put(key, value);\n        }\n    }\n\n    public UIBlock getCorrespondingUiBlockFor(Block block) {\n        try {\n            return blockUIBlockMap.get(block);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    public Block getCorrespondingBlockFor(UIBlock uiBlock) {\n        // TODO: decide whether another map is needed for the opposite direction or not (for efficiency)\n        // TODO: remove the block attribute from uiblocks and fill this method\n        return null;\n    }\n\n    public void adjustAllStatementBlockGaps() {\n        for (Block block : getBlockrGame().getAllBlocksInPA()) {\n            if (block instanceof StatementBlock) {\n                UIStatementBlock uiStatement = (UIStatementBlock) getCorrespondingUiBlockFor(block);\n                uiStatement.setGapSize(((StatementBlock) block).getGapSize());\n            }\n        }\n    }\n\n    public void adjustAllBlockPositions() {\n        for (Block block : getBlockrGame().getAllBlocksInPA()) {\n            UIBlock uiBlock = getCorrespondingUiBlockFor(block);\n            uiBlock.setPosition(block.getPosition());\n        }\n    }\n\n    public void setHighlightedBlock(UIBlock block) {\n        if (block == null) return;\n\n        if (highlightedBlock != null) highlightedBlock.setHighlightStateOn(false);\n        highlightedBlock = block;\n        highlightedBlock.setHighlightStateOn(true);\n    }\n\n    // TODO: find a way to \"adjust\" highlighted block\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/handlers/SharedData.java	(revision e1c35e1b0b4e9078dfbfee6a5f3f6618da72151f)
+++ code-frontend/src/main/java/com/swop/handlers/SharedData.java	(date 1589904759473)
@@ -3,6 +3,7 @@
 import com.swop.BlockrGame;
 import com.swop.GameWorldType;
 import com.swop.blocks.Block;
+import com.swop.blocks.BlockWithBody;
 import com.swop.blocks.StatementBlock;
 import com.swop.uiElements.UIBlock;
 import com.swop.uiElements.UIStatementBlock;
@@ -55,11 +56,12 @@
         return null;
     }
 
-    public void adjustAllStatementBlockGaps() {
+    public void adjustAllBodyBlockGaps() {
         for (Block block : getBlockrGame().getAllBlocksInPA()) {
-            if (block instanceof StatementBlock) {
+            if (block instanceof BlockWithBody) {
+                // TODO: find a way to not just consider UIStatementBlock
                 UIStatementBlock uiStatement = (UIStatementBlock) getCorrespondingUiBlockFor(block);
-                uiStatement.setGapSize(((StatementBlock) block).getGapSize());
+                uiStatement.setGapSize(((BlockWithBody) block).getGapSize());
             }
         }
     }
