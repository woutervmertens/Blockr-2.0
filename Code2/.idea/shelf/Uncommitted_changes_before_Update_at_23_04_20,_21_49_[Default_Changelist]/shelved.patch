Index: code-backend/src/main/java/com/swop/BlockrGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.Block;\nimport com.swop.command.AddBlockCommand;\nimport com.swop.command.DeleteBlockCommand;\nimport com.swop.command.ExecuteCommand;\nimport com.swop.command.ICommand;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.concurrent.atomic.AtomicReference;\n\n// TODO: 14/04/2020 comment\npublic class BlockrGame {\n    private final ProgramArea programArea;\n    private GameWorld gameWorld;\n    private final GameWorldType gameWorldType;\n    /**\n     * Maximum number of blocks that can be used\n     */\n    private final int maxBlocks;\n    private final static AtomicReference<BlockrGame> instance = new AtomicReference<>();\n    /**\n     * Stack for all the undo's\n     */\n    private Stack<ICommand> undoStack = new Stack<>();\n    /**\n     * Stack for all the redo's\n     */\n    private Stack<ICommand> redoStack = new Stack<>();\n\n    /**\n     * Initializes BlockrGame\n     * @param maxBlocks maximum number of blocks that can be used.\n     * @param gameWorldType given type of gameWorld\n     */\n    private BlockrGame(int maxBlocks,GameWorldType gameWorldType) {\n        this.maxBlocks = maxBlocks;\n        this.programArea = ProgramArea.getInstance();\n        this.gameWorldType = gameWorldType;\n        this.gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * Creates an instance of BlockrGame\n     * @param maxBlocks maximum number of blocks that can be used.\n     * @param gameWorldType given type of gameWorld\n     * @return Returns an instance of BlockrGame if there isn't one yet.\n     */\n    public synchronized  static BlockrGame createInstance(int maxBlocks,GameWorldType gameWorldType){\n        if(instance.get() == null) instance.set(new BlockrGame(maxBlocks,gameWorldType));\n        return instance.get();\n    }\n\n    /**\n     * @return Returns the BlockrGame instance if there is one otherwise an exception will be thrown.\n     */\n    public synchronized static BlockrGame getInstance(){\n        if(instance.get() == null) throw new IllegalStateException(\"BlockrGame instance used before created.\");\n        return instance.get();\n    }\n\n    /**\n     * @return Returns program that is currently in program area\n     */\n    public List<Block> getProgram() {\n        return programArea.getProgram();\n    }\n\n    /**\n     * @param block Given block\n     * @return Returns the position of the given block\n     */\n    public Point getBlockPosition(Block block) {\n        return block.getPosition();\n    }\n\n    /**\n     * Adds block to Program Area\n     * @param block given block\n     */\n    public void dropBlockInPA(Block block) {\n        if (block == null) throw new IllegalArgumentException();\n        executeCommand(new AddBlockCommand(block));\n    }\n\n    /**\n     * Removes block from Program Area\n     * @param draggedBlock given block\n     */\n    public void removeBlockFromPA(Block draggedBlock) {\n        executeCommand(new DeleteBlockCommand(draggedBlock));\n    }\n\n    /**\n     * Removes program block from Program area\n     * @param draggedBlock\n     */\n    public void removeProgramBlock(Block draggedBlock) {\n        programArea.removeProgramBlock(draggedBlock);\n    }\n\n    /**\n     * Executes next block\n     */\n    public void executeNext() {\n        if(programArea.getCurrentBlock() != null){\n            executeCommand(new ExecuteCommand(programArea.getCurrentBlock()));\n            programArea.setNextCurrentBlock();\n        }\n    }\n\n    /**\n     * Resets the game world and the program area\n     */\n    public void resetProgramExecution() {\n        programArea.resetProgramExecution();\n        gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns the number of blocks that are in the Program Area\n     */\n    public int getNumbBlocksInPA() {\n        return programArea.getAllBlocks().size();\n    }\n\n    /**\n     * @return Returns all the blocks that are in the Program Area\n     */\n    public List<Block> getAllBlocksInPA(){return programArea.getAllBlocks();}\n\n    /**\n     * position of a block is (x,y)\n     * @param x x-value of position\n     * @param y y-value of position\n     * @return returns a block if there is one at the given position otherwise null will be returned.\n     */\n    public Block getBlockInPaAt(int x, int y) {\n        return programArea.getBlockAt(x,y);\n    }\n\n    /**\n     * @return Returns true if the number of blocks in the program area is equal or greater than the maximum number of blocks\n     */\n    public boolean isPaletteHidden(){return (maxBlocks - getNumbBlocksInPA()) <= 0;}\n\n    /**\n     * @return Returns the game world\n     */\n    public GameWorld getGameWorld() {\n        return gameWorld;\n    }\n\n    /**\n     * @return Returns the game world type\n     */\n    public GameWorldType getGameWorldType() {return gameWorldType;}\n\n    /**\n     * redoes the previous undone operation if an operation is undone otherwise nothing happens\n     */\n    public void redoCommand(){\n        if(!redoStack.isEmpty()){\n            executeCommand(redoStack.pop());\n        }\n    }\n\n    /**\n     * undoes the previous operation if there is one otherwise nothing will be done\n     */\n    public void undoCommand(){\n        if(!undoStack.isEmpty()){\n            ICommand command = undoStack.pop();\n            command.undo();\n            redoStack.add(command);\n        }\n    }\n\n    /**\n     * Given command will be executed\n     * @param command given command\n     */\n    public void executeCommand(ICommand command){\n        command.execute();\n        undoStack.add(command);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/BlockrGame.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/main/java/com/swop/BlockrGame.java	(date 1587661249966)
@@ -1,7 +1,7 @@
 package com.swop;
 
 import com.swop.blocks.Block;
-import com.swop.command.AddBlockCommand;
+import com.swop.command.DropBlockCommand;
 import com.swop.command.DeleteBlockCommand;
 import com.swop.command.ExecuteCommand;
 import com.swop.command.ICommand;
@@ -82,23 +82,20 @@
      */
     public void dropBlockInPA(Block block) {
         if (block == null) throw new IllegalArgumentException();
-        executeCommand(new AddBlockCommand(block));
+        executeCommand(new DropBlockCommand(block));
     }
 
     /**
      * Removes block from Program Area
      * @param draggedBlock given block
+     * @param isRelease Boolean recording whether this is a release (outside PA) or not (a click)
      */
-    public void removeBlockFromPA(Block draggedBlock) {
-        executeCommand(new DeleteBlockCommand(draggedBlock));
-    }
-
-    /**
-     * Removes program block from Program area
-     * @param draggedBlock
-     */
-    public void removeProgramBlock(Block draggedBlock) {
-        programArea.removeProgramBlock(draggedBlock);
+    public void removeBlockFromPA(Block draggedBlock, boolean isRelease) {
+        if (isRelease) {
+            executeCommand(new DeleteBlockCommand(draggedBlock));
+        } else {
+            programArea.removeBlockFromPA(draggedBlock);
+        }
     }
 
     /**
@@ -163,6 +160,7 @@
      */
     public void redoCommand(){
         if(!redoStack.isEmpty()){
+            System.out.println("REDOSTACK: " + redoStack.size());
             executeCommand(redoStack.pop());
         }
     }
@@ -172,6 +170,7 @@
      */
     public void undoCommand(){
         if(!undoStack.isEmpty()){
+            System.out.println("UNDOSTACK: " + undoStack.size());
             ICommand command = undoStack.pop();
             command.undo();
             redoStack.add(command);
Index: code-backend/src/main/java/com/swop/command/DeleteBlockCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.command;\n\nimport com.swop.blocks.Block;\n\npublic class DeleteBlockCommand extends ProgramAreaCommand {\n    private Block block;\n\n    public DeleteBlockCommand(Block block){\n        this.block = block;\n    }\n\n    @Override\n    public void execute() {\n        programArea.removeBlockFromPA(block);\n    }\n\n    @Override\n    public void undo() {\n        programArea.dropBlock(block);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/command/DeleteBlockCommand.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/main/java/com/swop/command/DeleteBlockCommand.java	(date 1587661833531)
@@ -2,11 +2,15 @@
 
 import com.swop.blocks.Block;
 
+import java.awt.*;
+
 public class DeleteBlockCommand extends ProgramAreaCommand {
-    private Block block;
+    private final Block block;
+    private final Point previousPosition;
 
     public DeleteBlockCommand(Block block){
         this.block = block;
+        previousPosition = block.getPreviousDropPosition();
     }
 
     @Override
@@ -16,6 +20,7 @@
 
     @Override
     public void undo() {
+        block.setPosition(previousPosition);
         programArea.dropBlock(block);
     }
 }
Index: code-backend/src/main/java/com/swop/command/AddBlockCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.command;\n\nimport com.swop.blocks.Block;\n\npublic class AddBlockCommand extends ProgramAreaCommand {\n    private Block block;\n\n    public AddBlockCommand(Block block){\n        this.block = block;\n    }\n\n    @Override\n    public void execute() {\n        programArea.dropBlock(block);\n    }\n\n    @Override\n    public void undo() {\n        programArea.removeBlockFromPA(block);\n    }\n}\n
===================================================================
--- code-backend/src/main/java/com/swop/command/AddBlockCommand.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/main/java/com/swop/command/DropBlockCommand.java	(date 1587671197051)
@@ -2,20 +2,33 @@
 
 import com.swop.blocks.Block;
 
-public class AddBlockCommand extends ProgramAreaCommand {
-    private Block block;
+import java.awt.*;
 
-    public AddBlockCommand(Block block){
+// TODO: make DisplaceBlockCommand instead
+public class DropBlockCommand extends ProgramAreaCommand {
+    private final Block block;
+    private final Point position;
+    private final Point previousPosition;
+
+    public DropBlockCommand(Block block){
         this.block = block;
+        this.position = block.getPosition();
+        previousPosition = block.getPreviousDropPosition();
     }
 
     @Override
     public void execute() {
-        programArea.dropBlock(block);
+        programArea.dropBlockIn(block, position);
     }
 
     @Override
     public void undo() {
-        programArea.removeBlockFromPA(block);
+        try {
+            // TODO: ? block.setPreviousDropPosition(block.getPosition());
+            block.setPosition(previousPosition);
+            programArea.dropBlock(block);
+        } catch (IllegalArgumentException e) {
+            programArea.removeBlockFromPA(block);
+        }
     }
 }
Index: code-backend/src/test/java/com/swop/command/AddBlockCommandTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.command;\n\nimport com.swop.Action;\nimport com.swop.blocks.ActionBlock;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.awt.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass AddBlockCommandTest {\n\n    private Point position = new Point(1,1);\n    private int height =2;\n    private int width = 3;\n    private Action action = Action.MOVE_FORWARD;\n    private ActionBlock block = new ActionBlock(position, width, height, action);\n\n    private AddBlockCommand addBlockCommand = new AddBlockCommand(block);\n\n\n\n    @Test\n    void executeAndUndo() {\n        addBlockCommand.execute();\n        assertEquals(block, addBlockCommand.programArea.getAllBlocks().get(addBlockCommand.programArea.getAllBlocks().size() -1));\n        addBlockCommand.undo();\n        assertFalse(addBlockCommand.programArea.getAllBlocks().contains(block));\n    }\n\n}
===================================================================
--- code-backend/src/test/java/com/swop/command/AddBlockCommandTest.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/test/java/com/swop/command/DropBlockCommandTest.java	(date 1587655917126)
@@ -2,14 +2,13 @@
 
 import com.swop.Action;
 import com.swop.blocks.ActionBlock;
-import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
 
 import java.awt.*;
 
 import static org.junit.jupiter.api.Assertions.*;
 
-class AddBlockCommandTest {
+class DropBlockCommandTest {
 
     private Point position = new Point(1,1);
     private int height =2;
@@ -17,16 +16,16 @@
     private Action action = Action.MOVE_FORWARD;
     private ActionBlock block = new ActionBlock(position, width, height, action);
 
-    private AddBlockCommand addBlockCommand = new AddBlockCommand(block);
+    private DropBlockCommand dropBlockCommand = new DropBlockCommand(block);
 
 
 
     @Test
     void executeAndUndo() {
-        addBlockCommand.execute();
-        assertEquals(block, addBlockCommand.programArea.getAllBlocks().get(addBlockCommand.programArea.getAllBlocks().size() -1));
-        addBlockCommand.undo();
-        assertFalse(addBlockCommand.programArea.getAllBlocks().contains(block));
+        dropBlockCommand.execute();
+        assertEquals(block, dropBlockCommand.programArea.getAllBlocks().get(dropBlockCommand.programArea.getAllBlocks().size() -1));
+        dropBlockCommand.undo();
+        assertFalse(dropBlockCommand.programArea.getAllBlocks().contains(block));
     }
 
 }
\ No newline at end of file
Index: code-frontend/src/main/java/com/swop/MyCanvasWindow.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.handlers.DisplaceBlockHandler;\nimport com.swop.handlers.ExecuteProgramHandler;\nimport com.swop.uiElements.BlockTypes;\nimport com.swop.uiElements.UIBlock;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\n\npublic class MyCanvasWindow extends CanvasWindow {\n    private boolean isPaletteHidden = false;\n    // Variables\n    private UIBlock draggedBlock;\n    private Point pos = new Point(0, 0);\n    private int maxBlocks = 10;\n    // Handlers\n    BlockrGame blockrGame;\n    DisplaceBlockHandler displaceBlockHandler;\n    ExecuteProgramHandler executeProgramHandler;\n    //KeyHolds\n    boolean isHoldingCtrl = false;\n    boolean isHoldingShift = false;\n\n    /**\n     * Initializes a CanvasWindow object.\n     *\n     * @param title Window title\n     */\n    protected MyCanvasWindow(String title, GameWorldType gameWorldType) {\n        super(title);\n        blockrGame = BlockrGame.createInstance(maxBlocks,gameWorldType);\n        displaceBlockHandler = new DisplaceBlockHandler(blockrGame);\n        executeProgramHandler = new ExecuteProgramHandler(blockrGame);\n    }\n\n    @Override\n    protected void paint(Graphics g) {\n        isPaletteHidden = blockrGame.isPaletteHidden();\n        Windows.drawWindows(g, isPaletteHidden, displaceBlockHandler.getAllUIBlocksInPA(),blockrGame.getGameWorld());\n\n        if (draggedBlock != null) {\n            g.setColor(draggedBlock.getColor());\n            g.fillPolygon(draggedBlock.getPolygon());\n            g.setColor(Color.BLACK);\n            g.drawString(draggedBlock.getText(), draggedBlock.getTextPosition().x, draggedBlock.getTextPosition().y);\n        }\n        g.setColor(Color.BLACK);\n        g.drawString(\"# blocks available: \" + (maxBlocks - executeProgramHandler.getNumBlocksInPA()), width - 140, height - 10);\n    }\n\n    /**\n     * Calls the respective handlers for each supported mouse input.\n     *\n     * @param id         The MouseEvent id.\n     * @param x          The x position of the mouse action.\n     * @param y          The y position of the mouse action.\n     * @param clickCount The number of clicks associated with this event.\n     */\n    @Override\n    protected void handleMouseEvent(int id, int x, int y, int clickCount) {\n        super.handleMouseEvent(id, x, y, clickCount);\n        switch (id) {\n            case MouseEvent.MOUSE_PRESSED:\n                executeProgramHandler.reset();\n                draggedBlock = getUIBlock(x, y);\n                if (Windows.PROGRAM_AREA.isWithin(x,y) && draggedBlock != null) {\n                    displaceBlockHandler.handleProgramAreaForClickOn(draggedBlock);\n                }\n                break;\n            case MouseEvent.MOUSE_CLICKED:\n                break;\n            case MouseEvent.MOUSE_DRAGGED:\n                if (isBlockDragged()) {\n                    pos.x = x;\n                    pos.y = y;\n//                    int dx = x - draggedBlock.getPosition().x;\n//                    int dy = y - draggedBlock.getPosition().y;\n                    draggedBlock.setPosition((Point) pos.clone());\n//                    if (draggedBlock instanceof UIStatementBlock && draggedBlock.getCorrespondingBlock() != null) {\n//                        // TODO: instead of displacing the body blocks here, do it in setPosition() of body blocks\n//                        displaceBlockHandler.displaceAllBodyBlocksAndConditionsOfBlockWithDistance((UIStatementBlock)draggedBlock, dx, dy);\n//                    }\n                    repaint();\n                }\n                break;\n            case MouseEvent.MOUSE_RELEASED:\n                if (isBlockDragged()) {\n                    if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n                        displaceBlockHandler.handleReleaseInPA(draggedBlock);\n                    } else {\n                        displaceBlockHandler.handleReleaseOutsidePA(draggedBlock);\n                    }\n                    draggedBlock = null;\n                    repaint();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected mouse event: \" + id);\n        }\n        displaceBlockHandler.adjustAllBlockPositions();\n        displaceBlockHandler.adjustAllStatementBlockGaps();\n    }\n\n\n    /**\n     * Returns the UIBlock at the given click coordinates\n     *\n     * @param x Given x of click\n     * @param y Given y of click\n     * @return The UIBlock at the given coordinates or null\n     */\n    private UIBlock getUIBlock(int x, int y) {\n        if (Windows.PALETTE.isWithin(x, y) && !isPaletteHidden) {\n            BlockTypes type = Windows.getTypeOfClick(x, y);\n            return type.getNewUIBlock(x, y);\n        } else if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n            // TODO: check, check wat?\n            return displaceBlockHandler.getCorrespondingUiBlockFor(blockrGame.getBlockInPaAt(x, y));\n        }\n        return null;\n    }\n\n    /**\n     * Calls the respective handlers for each supported key input.\n     *\n     * @param id      The KeyEvent id (Pressed or typed).\n     * @param keyCode The numerical value of the key.\n     * @param keyChar The char value of the key.\n     */\n    @Override\n    protected void handleKeyEvent(int id, int keyCode, char keyChar) {\n        super.handleKeyEvent(id, keyCode, keyChar);\n        boolean bRepaint = false;\n        if (id == KeyEvent.KEY_PRESSED) {\n            switch (keyCode) {\n                case 116: //F5\n                    executeNext();\n                    bRepaint = true;\n                    break;\n                case 27: //Escape\n                    resetProgramExecution();\n                    bRepaint = true;\n                    break;\n                case 90: //Z\n                    if(isHoldingCtrl){\n                        if(isHoldingShift) redo();\n                        else undo();\n                        bRepaint = true;\n                    }\n            }\n            //ControlLeft/ControlRight\n            isHoldingCtrl = keyCode == 17;\n            //ShiftLeft/ShiftRight\n            isHoldingShift = keyCode == 16;\n            if(bRepaint)repaint();\n        }\n    }\n\n    private void executeNext() {\n        executeProgramHandler.executeNext();\n    }\n\n    private void undo(){\n        executeProgramHandler.undo();\n    }\n\n    private void redo(){\n        executeProgramHandler.redo();\n    }\n\n    private void resetProgramExecution() {\n        executeProgramHandler.reset();\n    }\n\n    /**\n     * Checks whether at this moment a block is being dragged.\n     */\n    private boolean isBlockDragged() {\n        return draggedBlock != null;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(date 1587660539141)
@@ -147,15 +147,23 @@
                     if(isHoldingCtrl){
                         if(isHoldingShift) redo();
                         else undo();
+                        isHoldingShift = false;
+                        isHoldingCtrl = false;
                         bRepaint = true;
                     }
             }
-            //ControlLeft/ControlRight
-            isHoldingCtrl = keyCode == 17;
-            //ShiftLeft/ShiftRight
-            isHoldingShift = keyCode == 16;
+
+            if (keyCode == 17) isHoldingCtrl = true;
+            if (keyCode == 16) isHoldingShift = true;
+
+            System.out.println("Ctrl " + isHoldingCtrl);
+            System.out.println("Shift " + isHoldingShift);
+
             if(bRepaint)repaint();
         }
+
+        displaceBlockHandler.adjustAllBlockPositions();
+        displaceBlockHandler.adjustAllStatementBlockGaps();
     }
 
     private void executeNext() {
Index: code-backend/src/test/java/com/swop/BlockrGameTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.ActionBlock;\nimport com.swop.blocks.Block;\nimport com.swop.blocks.ConditionBlock;\nimport com.swop.blocks.WhileBlock;\nimport com.swop.command.AddBlockCommand;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.awt.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BlockrGameTest {\n\n    private String[] args= {\"com.swop.RobotGameWorldType\"};\n    GameWorldType gameWorldType;\n\n    private int maxBlocks = 2;\n    private BlockrGame blockrGame;\n    private GameWorld gameWorld ;\n\n    private Point aPosition = new Point(1,1);\n    private int aWidth = 3;\n    private int aHeight = 2;\n    private Action action = Action.MOVE_FORWARD;\n\n    private ActionBlock actionBlock = new ActionBlock(aPosition,aWidth,aHeight,action);\n\n    private Point wPosition = new Point(1,3);\n    private int wWidth = 4;\n    private int wHeight = 2;\n\n    private WhileBlock whileBlock = new WhileBlock(wPosition, wWidth, wHeight);\n\n    private ConditionBlock conditionBlock = new ConditionBlock(new Point(3,2),true, 1,2);\n\n\n    private AddBlockCommand addBlockCommand = new AddBlockCommand(actionBlock);\n\n    @BeforeEach\n    void setup(){\n        {\n            try {\n                Class<?> clasz = Class.forName(args[0]);\n                gameWorldType = (GameWorldType) clasz.getConstructor().newInstance();\n            } catch (Exception e) {\n                e.printStackTrace(); }\n        }\n\n       blockrGame = BlockrGame.createInstance(maxBlocks, gameWorldType);\n       gameWorld = blockrGame.getGameWorld();\n       whileBlock.addConditionBlock(conditionBlock);\n    }\n    @Test\n    void getAndCreateInstance() {\n        assertNotNull(BlockrGame.getInstance(), \"The instance isn't null\");\n        assertEquals(BlockrGame.getInstance(), blockrGame, \"instances aren't the same\" );\n        assertEquals(BlockrGame.getInstance(), BlockrGame.createInstance(maxBlocks, gameWorldType), \"second instance made\");\n    }\n\n    @Test\n    void getBlockPosition() {\n        assertEquals(blockrGame.getBlockPosition(whileBlock).x, wPosition.x,\"The x-value of the expected and actual position of the block are different\");\n        assertEquals(blockrGame.getBlockPosition(whileBlock).y, wPosition.y,\"The y-value of the expected and actual position of the block are different\");\n    }\n\n    @Test\n    void removeProgramBlock() {\n    }\n\n    /**\n     * checks if the functions dropBlockInPA(), getNumbBlocksInPA(), isPaletteHidden(), executeNext() and removeBlockFromPA() is implemented well\n     */\n    @Test\n    void addRemoveNumbHidden(){\n        assertTrue(blockrGame.getAllBlocksInPA().isEmpty(), \"Program area isn't empty\");\n        assertEquals(0, blockrGame.getNumbBlocksInPA(), \"Number of blocks isn't 0\");\n        assertFalse(blockrGame.isPaletteHidden(),\"maximum isn't reached\");\n\n        blockrGame.dropBlockInPA(whileBlock);\n        assertEquals(1, blockrGame.getAllBlocksInPA().size(), \"didn't add block to program area\");\n        assertEquals(1, blockrGame.getNumbBlocksInPA(), \"Number of blocks isn't 1\");\n        assertEquals(ProgramArea.getInstance().getCurrentBlock(), whileBlock, \"WhileBlock isn't the current block\");\n        assertFalse(blockrGame.isPaletteHidden(),\"maximum isn't reached\");\n\n        blockrGame.dropBlockInPA(actionBlock);\n        assertEquals(ProgramArea.getInstance().getCurrentBlock(), whileBlock, \"WhileBlock isn't the current block\");\n        assertEquals(2, blockrGame.getAllBlocksInPA().size(), \"didn't add block to program area\");\n        assertEquals(2, blockrGame.getNumbBlocksInPA(), \"Number of blocks isn't 2\");\n        assertTrue(blockrGame.isPaletteHidden(),\"maximum is reached\");\n\n        blockrGame.executeNext();\n        assertEquals(ProgramArea.getInstance().getCurrentBlock(), actionBlock, \"ActionBlock isn't the current block\");\n\n        blockrGame.removeBlockFromPA(whileBlock);\n        assertEquals(1, blockrGame.getAllBlocksInPA().size(), \"didn't add block to program area\");\n        assertEquals(1, blockrGame.getNumbBlocksInPA(), \"Number of blocks isn't 1\");\n    }\n\n\n\n\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/test/java/com/swop/BlockrGameTest.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/test/java/com/swop/BlockrGameTest.java	(date 1587661285151)
@@ -1,11 +1,9 @@
 package com.swop;
 
 import com.swop.blocks.ActionBlock;
-import com.swop.blocks.Block;
 import com.swop.blocks.ConditionBlock;
 import com.swop.blocks.WhileBlock;
-import com.swop.command.AddBlockCommand;
-import org.junit.jupiter.api.BeforeAll;
+import com.swop.command.DropBlockCommand;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -38,7 +36,7 @@
     private ConditionBlock conditionBlock = new ConditionBlock(new Point(3,2),true, 1,2);
 
 
-    private AddBlockCommand addBlockCommand = new AddBlockCommand(actionBlock);
+    private DropBlockCommand dropBlockCommand = new DropBlockCommand(actionBlock);
 
     @BeforeEach
     void setup(){
@@ -95,7 +93,7 @@
         blockrGame.executeNext();
         assertEquals(ProgramArea.getInstance().getCurrentBlock(), actionBlock, "ActionBlock isn't the current block");
 
-        blockrGame.removeBlockFromPA(whileBlock);
+        blockrGame.removeBlockFromPA(whileBlock, true);
         assertEquals(1, blockrGame.getAllBlocksInPA().size(), "didn't add block to program area");
         assertEquals(1, blockrGame.getNumbBlocksInPA(), "Number of blocks isn't 1");
     }
Index: code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.handlers;\n\nimport com.swop.BlockrGame;\nimport com.swop.blocks.Block;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.uiElements.UIBlock;\nimport com.swop.uiElements.UIStatementBlock;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class DisplaceBlockHandler {\n    /**\n     * Map with as keys all the backend blocks present in the PA and their corresponding ui block as value.\n     */\n    private Map<Block, UIBlock> blockUIBlockMap = new HashMap<>();\n\n    private Map<Block, UIBlock> getBlockUIBlockMap() {\n        return blockUIBlockMap;\n    }\n\n    public void putInBlockUIBlockMap(Block key, UIBlock value) {\n        blockUIBlockMap.put(key, value);\n    }\n\n    public UIBlock getCorrespondingUiBlockFor(Block block) {\n        try {\n            return blockUIBlockMap.get(block);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    public DisplaceBlockHandler(BlockrGame blockrGame) {\n        this.blockrGame = blockrGame;\n    }\n\n    /**\n     * Connection with backend\n     */\n    private BlockrGame blockrGame;\n\n    /**\n     * @pre draggedBlock.getPosition() is inside the PA\n     */\n    public void handleReleaseInPA(UIBlock draggedBlock) {\n        if (draggedBlock.getCorrespondingBlock() == null)\n            draggedBlock.makeNewCorrespondingBlock();\n\n        Block backendBlock = draggedBlock.getCorrespondingBlock();\n        if (!getBlockUIBlockMap().containsKey(backendBlock)) {\n            putInBlockUIBlockMap(backendBlock, draggedBlock);\n        }\n        blockrGame.dropBlockInPA(backendBlock);\n        draggedBlock.setPosition(blockrGame.getBlockPosition(backendBlock));\n    }\n\n    public void adjustAllStatementBlockGaps() {\n        for (Block block : blockrGame.getAllBlocksInPA()) {\n            if (block instanceof StatementBlock) {\n                UIStatementBlock uiStatement = (UIStatementBlock) getCorrespondingUiBlockFor(block);\n                uiStatement.setGapSize(((StatementBlock) block).getGapSize());\n            }\n        }\n    }\n\n    public void adjustAllBlockPositions() {\n        for (Block block : blockrGame.getAllBlocksInPA()) {\n            UIBlock uiBlock = getCorrespondingUiBlockFor(block);\n            uiBlock.setPosition(block.getPosition());\n        }\n    }\n\n    public void handleReleaseOutsidePA(UIBlock draggedBlock) {\n        Block backendBlock = draggedBlock.getCorrespondingBlock();\n        if (backendBlock != null) {\n            if (backendBlock instanceof StatementBlock) {\n\n                for (Block bodyBlock : new ArrayList<>(((StatementBlock) backendBlock).getBodyBlocks())) {\n                    blockUIBlockMap.remove(bodyBlock);\n                    blockrGame.removeBlockFromPA(bodyBlock);\n                }\n            }\n            //remove from the map in DisplaceBlockHandler\n            blockUIBlockMap.remove(backendBlock);\n            //remove the block from program area\n            blockrGame.removeBlockFromPA(backendBlock);\n            // Remove all bodies and conditions as well from program area\n            if (backendBlock instanceof StatementBlock) {\n                for (Block bodyBlock : ((StatementBlock) backendBlock).getBodyBlocks()) {\n                    blockrGame.removeBlockFromPA(bodyBlock);\n                }\n                for (Block bodyBlock : ((StatementBlock) backendBlock).getConditions()) {\n                    blockrGame.removeBlockFromPA(bodyBlock);\n                }\n            }\n        }\n    }\n\n    public List<UIBlock> getAllUIBlocksInPA() {\n        List<Block> backBlocks = blockrGame.getAllBlocksInPA();\n        List<UIBlock> returnUIBlocks = new ArrayList<>();\n        for (Block block : backBlocks) {\n            returnUIBlocks.add(getCorrespondingUiBlockFor(block));\n        }\n        return returnUIBlocks;\n    }\n\n    public void handleProgramAreaForClickOn(UIBlock clickedBlock) {\n        if (clickedBlock == null) throw new IllegalArgumentException();\n\n        blockrGame.removeBlockFromPA(clickedBlock.getCorrespondingBlock());\n\n        // TODO: remove\n        //adjustAllBlockPositions();\n        //adjustAllStatementBlockGaps();\n    }\n\n    public void displaceAllBodyBlocksAndConditionsOfBlockWithDistance(UIStatementBlock draggedBlock, int dx, int dy) {\n        // Body blocks\n        List<Block> bodyAndConditionBlocks = ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks();\n        // Adding conditions\n        bodyAndConditionBlocks.addAll(((StatementBlock) draggedBlock.getCorrespondingBlock()).getConditions());\n\n        for (Block block : bodyAndConditionBlocks) {\n            block.setPosition(new Point(block.getPosition().x + dx, block.getPosition().y + dy));\n            if (block instanceof StatementBlock) {\n                for (Block bodyBlock2 : ((StatementBlock) block).getBodyBlocks()) {\n                    bodyBlock2.setPosition(new Point(bodyBlock2.getPosition().x + dx, bodyBlock2.getPosition().y + dy));\n                }\n            }\n        }\n        adjustAllBlockPositions();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(date 1587661249962)
@@ -41,7 +41,7 @@
     /**
      * Connection with backend
      */
-    private BlockrGame blockrGame;
+    private final BlockrGame blockrGame;
 
     /**
      * @pre draggedBlock.getPosition() is inside the PA
@@ -80,21 +80,21 @@
             if (backendBlock instanceof StatementBlock) {
 
                 for (Block bodyBlock : new ArrayList<>(((StatementBlock) backendBlock).getBodyBlocks())) {
-                    blockUIBlockMap.remove(bodyBlock);
-                    blockrGame.removeBlockFromPA(bodyBlock);
+                    // blockUIBlockMap.remove(bodyBlock);
+                    blockrGame.removeBlockFromPA(bodyBlock, true);
                 }
             }
-            //remove from the map in DisplaceBlockHandler
-            blockUIBlockMap.remove(backendBlock);
+
+            //blockUIBlockMap.remove(backendBlock);
             //remove the block from program area
-            blockrGame.removeBlockFromPA(backendBlock);
+            blockrGame.removeBlockFromPA(backendBlock, true);
             // Remove all bodies and conditions as well from program area
             if (backendBlock instanceof StatementBlock) {
                 for (Block bodyBlock : ((StatementBlock) backendBlock).getBodyBlocks()) {
-                    blockrGame.removeBlockFromPA(bodyBlock);
+                    blockrGame.removeBlockFromPA(bodyBlock, true);
                 }
                 for (Block bodyBlock : ((StatementBlock) backendBlock).getConditions()) {
-                    blockrGame.removeBlockFromPA(bodyBlock);
+                    blockrGame.removeBlockFromPA(bodyBlock, true);
                 }
             }
         }
@@ -111,14 +111,14 @@
 
     public void handleProgramAreaForClickOn(UIBlock clickedBlock) {
         if (clickedBlock == null) throw new IllegalArgumentException();
-
-        blockrGame.removeBlockFromPA(clickedBlock.getCorrespondingBlock());
-
-        // TODO: remove
-        //adjustAllBlockPositions();
-        //adjustAllStatementBlockGaps();
+        Block backendBlock = clickedBlock.getCorrespondingBlock();
+        backendBlock.setPreviousDropPosition(backendBlock.getPosition());
+        blockrGame.removeBlockFromPA(backendBlock, false);
+        adjustAllBlockPositions();
+        adjustAllStatementBlockGaps();
     }
 
+    // TODO: delete
     public void displaceAllBodyBlocksAndConditionsOfBlockWithDistance(UIStatementBlock draggedBlock, int dx, int dy) {
         // Body blocks
         List<Block> bodyAndConditionBlocks = ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks();
Index: code-backend/src/main/java/com/swop/ProgramArea.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.*;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A program area that handles drops of blocks in it for constructing program(s).\n * It has no notion of position or width or height.\n */\npublic class ProgramArea implements PushBlocks {\n    private final static AtomicReference<ProgramArea> instance = new AtomicReference<>();\n\n    private final int radius = 15;  // Radius for connections\n    /**\n     * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.\n     * Nested blocks (inside StatementBlocks) should be accessed using ''\n     */\n    private List<Block> program = new LinkedList<>();\n    /**\n     * List recording all blocks currently present in program area\n     */\n    private List<Block> allBlocks = new ArrayList<>();\n    private Block currentBlock;\n\n    public List<Block> getAllBlocks() {\n        return allBlocks;\n    }\n\n    public List<Block> getProgram() {\n        return program;\n    }\n\n    public synchronized static ProgramArea getInstance() {\n        if (instance.get() == null) instance.set(new ProgramArea());\n        return instance.get();\n    }\n\n    /**\n     * @pre the position of the block is inside the ui program area.\n     */\n    public void dropBlock(Block draggedBlock) {\n        if (!allBlocks.contains(draggedBlock)) allBlocks.add(draggedBlock);\n        resetProgramExecution();\n        if (allBlocks.size() == 1) {\n            program.add(draggedBlock);\n            resetProgramExecution();\n            return;\n        }\n\n        // 1) Find close block and connection point\n        Block closeBlock;\n        if (!(draggedBlock instanceof ConditionBlock)) {\n            // 1) plug\n            closeBlock = getBlockWithPlugForBlockWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                if (program.contains(closeBlock)) {\n                    addProgramBlockAfter(draggedBlock, closeBlock);\n                } else if (closeBlock.getParentStatement() != null) {\n                    closeBlock.getParentStatement().addBodyBlockAfter(draggedBlock, closeBlock);\n                }\n                draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n            } else {\n                // 2) socket\n                closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);\n                if (closeBlock != null) {\n                    if (program.contains(closeBlock)) {\n                        addProgramBlockBefore(draggedBlock, closeBlock);\n                    } else if (closeBlock.getParentStatement() != null) {\n                        closeBlock.getParentStatement().addBodyBlockBefore(draggedBlock, closeBlock);\n                    }\n                    draggedBlock.setPosition(getConnectionPoint(draggedBlock, closeBlock));\n                } else {\n                    // 3) statement body\n                    closeBlock = getStatementBlockBodyPlugWithinRadius(draggedBlock, radius);\n                    if (closeBlock != null) {\n                        draggedBlock.setPosition(((StatementBlock) closeBlock).getBodyPlugPosition());\n                        ((StatementBlock) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);\n                    }\n                }\n            }\n        } else {\n            // 4) statement condition\n            closeBlock = getStatementBlockConditionPlugWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                draggedBlock.setPosition(((StatementBlock) closeBlock).getConditionPlugPosition());\n                ((StatementBlock) closeBlock).addConditionBlock((ConditionBlock) draggedBlock);\n            }\n            // TODO: connect condition to other conditions\n        }\n\n        // 2) Push program blocks if dragged block was added to a statement body\n        if (draggedBlock.getParentStatement() != null) {\n            Block currentBlock = draggedBlock;\n            while (currentBlock.getParentStatement() != null) {\n                currentBlock = currentBlock.getParentStatement();\n            }\n\n            if (getProgram().contains(currentBlock)) {\n                // Now currentBlock is a block from the program\n                int distance = draggedBlock.getHeight() + draggedBlock.getStep();\n                if (draggedBlock instanceof StatementBlock) distance += ((StatementBlock) draggedBlock).getGapSize();\n                PushBlocks.pushFrom(getProgram(), getProgram().indexOf(currentBlock) + 1, distance);\n            }\n        }\n\n        System.out.println(\"Program has \" + getProgram().size() + \" blocks !\");\n    }\n\n    /**\n     * @return Returns current block from the program area\n     */\n    public Block getCurrentBlock() {\n        return currentBlock;\n    }\n\n    /**\n     * Sets the next block as the current block\n     */\n    public void setNextCurrentBlock() {\n        int i = program.indexOf(currentBlock);\n        Block b = (i + 1 < program.size()) ? program.get(i + 1) : null;\n        setCurrentBlock(b);\n    }\n\n    /**\n     * Sets the givven block as the current block\n     *\n     * @param first given block\n     */\n    private void setCurrentBlock(Block first) {\n        this.currentBlock = first;\n    }\n\n    /**\n     * @param x\n     * @param y\n     * @return returns the block at the given position (x,y) if that block exists otherwise null will be returned.\n     */\n    public Block getBlockAt(int x, int y) {\n        Optional<Block> found = getAllBlocks().stream().filter(block1 -> block1.isPositionOn(x, y)).findAny();\n        System.out.println(found);\n        return found.orElse(null);\n    }\n\n    /**\n     * @param b Point1\n     * @param p Point2\n     * @return Returns the distance between the two given points.\n     */\n    private static int getDistance(Point b, Point p) {\n        return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));\n    }\n\n    /**\n     * @param draggedBlock block that is dragged\n     * @param closeBlock   closest block to the dragged block\n     * @return Returns the connection point if precondition is valid\n     * @pre Both blocks are close enough to each other for connection\n     */\n    public Point getConnectionPoint(Block draggedBlock, Block closeBlock) {\n        if (draggedBlock.isUnder(closeBlock)) return closeBlock.getPlugPosition();\n        else\n            return new Point(closeBlock.getSocketPosition().x, closeBlock.getSocketPosition().y - draggedBlock.getHeight() - 10);\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the block with plug that is within the given radius of the given block\n     */\n    private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || (block instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (block instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            // TODO: maybe type cast with interfaces\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param uiBlock given block\n     * @param radius  given radius\n     * @return Returns the block with socket within the given radius of the given block\n     */\n    private Block getBlockWithSocketForBlockWithinRadius(Block uiBlock, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == uiBlock || (uiBlock instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (uiBlock instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            // TODO: maybe type cast with interfaces\n            if (getDistance(uiBlock.getPlugPosition(), b.getSocketPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    // TODO: connect to last body block fix\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block body plug within the given radius of the given block\n     */\n    private Block getStatementBlockBodyPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getBodyPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    // TODO: connect to last condition of the conditions of statement (add getConditionPlugWithinRadius() )\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block condition plug within the given radius of the given block\n     */\n    private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list after the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockAfter(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock) + 1);\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list before the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockBefore(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock));\n    }\n\n    private void insertProgramBlockAtIndex(Block block, int index) {\n        program.add(index, block);\n        int distance = block.getHeight() + block.getStep();\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index + 1, distance);\n    }\n\n    /**\n     * @param block given block\n     *              Remove the given block from the program of this program area.\n     *              This does not mean that the given block is removed or outside the PA.\n     * @pre getProgram().contains(block)\n     */\n    public void removeProgramBlock(Block block) {\n        assert getProgram().contains(block);\n        int index = program.indexOf(block);\n        program.remove(block);\n\n        int distance = -block.getHeight() - block.getStep();\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index, distance);\n\n        // TODO: Correct method\n//        PushBlocks.pushBlocksInListFromIndexWithDistance(getProgram(), getProgram().indexOf(block) + 1,\n//                -block.getHeight() - block.getStep());\n//        PushBlocks.pushBodyBlocksOfSuperiorParents(getProgram(), -block.getHeight() - block.getStep());\n\n        getProgram().remove(block);\n\n        // TODO: remove from allBlocks as well !\n\n//        if (index > 0) {\n//            for (int i = index; i < getProgram().size(); i++) {\n//                Block currentBlock = getProgram().get(i);\n//                currentBlock.setPosition(new Point(currentBlock.getPosition().x,\n//                        currentBlock.getPosition().y - block.getHeight()));\n//            }\n//        }\n    }\n\n    /**\n     * Remove the clickedBlock from this program area\n     *\n     * @param clickedBlock block that's dragged\n     */\n    public void removeBlockFromPA(Block clickedBlock) {\n        if (!(clickedBlock instanceof ConditionBlock)) {\n            StatementBlock parentStatement = clickedBlock.getParentStatement();\n            if (parentStatement != null) {\n                parentStatement.removeBodyBlock(clickedBlock);\n            }\n\n        } else {\n            // TODO: remove ConditionBlock\n        }\n\n        allBlocks.remove(clickedBlock);\n        if (getProgram().contains(clickedBlock)) {\n            removeProgramBlock(clickedBlock);\n            // TODO: check if this body is correct\n        }\n        // TODO: remove correctly (for statement block gaps etc.) --> inverse of drop\n    }\n\n    /**\n     * Resets the program area, first block will be current block\n     */\n    public void resetProgramExecution() {\n        try {\n            setCurrentBlock(((LinkedList<Block>) program).getFirst());\n        } catch (NoSuchElementException ignore) {\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/ProgramArea.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/main/java/com/swop/ProgramArea.java	(date 1587662867449)
@@ -14,7 +14,7 @@
 public class ProgramArea implements PushBlocks {
     private final static AtomicReference<ProgramArea> instance = new AtomicReference<>();
 
-    private final int radius = 15;  // Radius for connections
+    private final int radius = 10;  // Radius for connections
     /**
      * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.
      * Nested blocks (inside StatementBlocks) should be accessed using ''
@@ -39,9 +39,12 @@
         return instance.get();
     }
 
-    /**
-     * @pre the position of the block is inside the ui program area.
-     */
+    // TODO: remove method ?
+    public void dropBlockIn(Block draggedBlock, Point position) {
+        draggedBlock.setPosition(position);
+        dropBlock(draggedBlock);
+    }
+
     public void dropBlock(Block draggedBlock) {
         if (!allBlocks.contains(draggedBlock)) allBlocks.add(draggedBlock);
         resetProgramExecution();
@@ -155,6 +158,10 @@
         return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));
     }
 
+//    private static boolean isAbove(Block block1, Block block2) {
+//        return block1.getPosition().y < block2.getPosition().y;
+//    }
+
     /**
      * @param draggedBlock block that is dragged
      * @param closeBlock   closest block to the dragged block
@@ -282,7 +289,7 @@
      *              This does not mean that the given block is removed or outside the PA.
      * @pre getProgram().contains(block)
      */
-    public void removeProgramBlock(Block block) {
+    private void removeProgramBlock(Block block) {
         assert getProgram().contains(block);
         int index = program.indexOf(block);
         program.remove(block);
@@ -292,21 +299,10 @@
         PushBlocks.pushFrom(program, index, distance);
 
         // TODO: Correct method
-//        PushBlocks.pushBlocksInListFromIndexWithDistance(getProgram(), getProgram().indexOf(block) + 1,
-//                -block.getHeight() - block.getStep());
-//        PushBlocks.pushBodyBlocksOfSuperiorParents(getProgram(), -block.getHeight() - block.getStep());
 
         getProgram().remove(block);
 
-        // TODO: remove from allBlocks as well !
-
-//        if (index > 0) {
-//            for (int i = index; i < getProgram().size(); i++) {
-//                Block currentBlock = getProgram().get(i);
-//                currentBlock.setPosition(new Point(currentBlock.getPosition().x,
-//                        currentBlock.getPosition().y - block.getHeight()));
-//            }
-//        }
+        // TODO: remove from allBlocks as well ? Or is it already done ?
     }
 
     /**
@@ -318,7 +314,19 @@
         if (!(clickedBlock instanceof ConditionBlock)) {
             StatementBlock parentStatement = clickedBlock.getParentStatement();
             if (parentStatement != null) {
+                // 1) Remove the body and push all superior body-blocks up
                 parentStatement.removeBodyBlock(clickedBlock);
+                // 2) Push program up
+                // 2.1) Find most superior program block
+                while (parentStatement.getParentStatement() != null) {
+                    parentStatement = parentStatement.getParentStatement();
+                }
+                if (getProgram().contains(parentStatement)) {
+                    int distance = -clickedBlock.getHeight() - clickedBlock.getStep();
+                    if (clickedBlock instanceof StatementBlock)
+                        distance -= ((StatementBlock) clickedBlock).getGapSize();
+                    PushBlocks.pushFrom(program, program.indexOf(parentStatement) + 1, distance);
+                }
             }
 
         } else {
Index: code-backend/src/main/java/com/swop/blocks/Block.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop.blocks;\n\nimport com.swop.BlockrGame;\nimport com.swop.GameWorld;\n\nimport java.awt.*;\n\npublic abstract class Block implements Cloneable {\n    private final int width;\n    private final int height;\n    protected final int step;\n    protected ExecuteType executeType;\n    private StatementBlock parentStatement;\n\n    protected Block(Point position, int width, int height) {\n        this.setPosition(position);\n        this.width = width;\n        this.height = height;\n        step = height / 6;\n    }\n\n    public Block clone(){\n        try {\n            return (Block)super.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public int getStep() {\n        return step;\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n    public ExecuteType getExecuteType() {\n        return executeType;\n    }\n\n    public StatementBlock getParentStatement() {\n        return parentStatement;\n    }\n\n    public void setParentStatement(StatementBlock parentStatement) {\n        this.parentStatement = parentStatement;\n    }\n\n    /**\n     * Check whether the given position is on this block.\n     */\n    public boolean isPositionOn(int x, int y) {\n        return (x > position.x && x < position.x + width) && (y > position.y && y < position.y + height);\n    }\n\n    /**\n     * Check whether this block is under the given block\n     */\n    public boolean isUnder(Block block) {\n        return this.getPosition().y > block.getPosition().y;\n    }\n\n    public Point getPosition() {\n        return position;\n    }\n\n    public void setPosition(Point position) {\n        this.position = position;\n    }\n\n    private Point position;\n\n    public GameWorld getGameWorld() {\n        return BlockrGame.getInstance().getGameWorld();\n    }\n\n    public abstract Point getSocketPosition();\n\n    public abstract Point getPlugPosition();\n\n    // TODO: should we add getParentStatement() ? Is is needed ?\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/blocks/Block.java	(revision 54b5ea3165f843b3e3c41f35707b90bc1d9111c3)
+++ code-backend/src/main/java/com/swop/blocks/Block.java	(date 1587656027062)
@@ -70,12 +70,23 @@
         return position;
     }
 
+    public Point getPreviousDropPosition() {
+        return previousDropPosition;
+    }
+
     public void setPosition(Point position) {
+        if (position == null) throw new IllegalArgumentException();
         this.position = position;
     }
 
+    public void setPreviousDropPosition(Point previousDropPosition) {
+        this.previousDropPosition = previousDropPosition;
+    }
+
     private Point position;
 
+    private Point previousDropPosition;
+
     public GameWorld getGameWorld() {
         return BlockrGame.getInstance().getGameWorld();
     }
