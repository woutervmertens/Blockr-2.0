Index: code-backend/src/main/java/com/swop/ProgramArea.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.*;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.*;\n\n/**\n * A program area that handles drops of blocks in it for constructing program(s).\n * It has no notion of position or width or height.\n */\npublic class ProgramArea implements PushBlocks {\n\n    private final int radius = 10;  // Radius for connections\n    /**\n     * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.\n     * Nested blocks (inside blocks with bodies) should be accessed using 'getNextBodyBlock()'\n     */\n    private final List<Block> program = new LinkedList<>();\n    /**\n     * List recording all blocks currently present in program area\n     */\n    private final List<Block> allBlocks = new ArrayList<>();\n    private Block nextProgramBlock;\n\n    /**\n     * @param b Point1\n     * @param p Point2\n     * @return Returns the distance between the two given points.\n     */\n    private static int getDistance(Point b, Point p) {\n        return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));\n    }\n\n    public List<Block> getAllBlocks() {\n        return allBlocks;\n    }\n\n    public List<Block> getProgram() {\n        return program;\n    }\n\n    public void dropBlockIn(Block draggedBlock, Point position) {\n        draggedBlock.setPosition(position);\n        dropBlock(draggedBlock);\n    }\n\n    public void dropBlock(Block draggedBlock) {\n        // TODO: handle the drop\n        if (allBlocks.size() == 0) {\n            allBlocks.add(draggedBlock);\n            program.add(draggedBlock);\n            nextProgramBlock = draggedBlock;\n            return;\n        } else if (!allBlocks.contains(draggedBlock)) {\n            allBlocks.add(draggedBlock);\n            // TODO: fix dees\n//            if (getNextProgramBlock() == null){\n//                setNextProgramBlock(getMostUpperBlock());\n//                program.add(getNextProgramBlock());;\n//            }\n        }\n\n        // 1) Handle Connection\n        handleConnections(draggedBlock);\n\n        // 2) Push program blocks if dragged block was added to a statement body\n        pushProgramBlocksForBody(draggedBlock);\n\n        // 3) Reset program execution (and adjust next block)\n        resetProgramExecution();\n\n        System.out.println(\"Program has \" + getProgram().size() + \" blocks !\");\n    }\n\n    /**\n     * Push program blocks if the given dragged block was added to a statement body\n     */\n    private void pushProgramBlocksForBody(Block draggedBlock) {\n        if (draggedBlock.getParentBlock() != null && !(draggedBlock instanceof ConditionBlock)) {\n\n            Block currentBlock = draggedBlock;\n            while (currentBlock.getParentBlock() != null) {\n                currentBlock = currentBlock.getParentBlock();\n            }\n            if (getProgram().contains(currentBlock)) {\n                // Now currentBlock is a block from the program\n                int distance = draggedBlock.getHeight() + draggedBlock.getStep();\n                if (draggedBlock instanceof BlockWithBody) distance += ((BlockWithBody) draggedBlock).getGapSize();\n                PushBlocks.pushFrom(getProgram(), getProgram().indexOf(currentBlock) + 1, distance);\n            }\n        }\n    }\n\n\n    /**\n     * Handle eventual connections of close blocks for the given draggedblock.\n     */\n    private void handleConnections(Block draggedBlock) {\n        if (draggedBlock instanceof VerticallyConnectable) handleVerticalConnections(draggedBlock);\n        if (draggedBlock instanceof HorizontallyConnectable) handleHorizontalConnections(draggedBlock);\n    }\n\n    private void handleVerticalConnections(Block draggedBlock) {\n        assert (draggedBlock instanceof VerticallyConnectable);\n        Block closeBlock;\n        // 1) plug\n        closeBlock = getBlockWithPlugForBlockWithinRadius(draggedBlock, radius);\n        if (closeBlock != null) {\n            connectPlug(draggedBlock, closeBlock);\n        } else {\n            // 2) socket\n            closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                connectSocket(draggedBlock, closeBlock);\n                draggedBlock.setPosition(getVerticalConnectionPoint(draggedBlock, closeBlock));\n            } else {\n                // 3) body\n                closeBlock = getBlockWithBodyPlugWithinRadius(draggedBlock, radius);\n                if (closeBlock != null) {\n                    draggedBlock.setPosition(((BlockWithBody) closeBlock).getBodyPlugPosition());\n                    ((BlockWithBody) closeBlock).insertBodyBlockAtIndex(draggedBlock, 0);\n                }\n            }\n        }\n    }\n\n    private void connectPlug(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockAfter(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentBlock() != null) {\n            closeBlock.getParentBlock().addBodyBlockAfter(draggedBlock, closeBlock);\n        }\n        draggedBlock.setPosition(getVerticalConnectionPoint(draggedBlock, closeBlock));\n    }\n\n    private void connectSocket(Block draggedBlock, Block closeBlock) {\n        if (program.contains(closeBlock)) {\n            addProgramBlockBefore(draggedBlock, closeBlock);\n        } else if (closeBlock.getParentBlock() != null) {\n            closeBlock.getParentBlock().addBodyBlockBefore(draggedBlock, closeBlock);\n        }\n    }\n\n    private void handleHorizontalConnections(Block draggedBlock) {\n        assert draggedBlock instanceof HorizontallyConnectable;\n        if (draggedBlock instanceof ConditionBlock) {\n            Block closeBlock;\n            closeBlock = getStatementBlockConditionPlugWithinRadius(draggedBlock, radius);\n            if (closeBlock != null) {\n                draggedBlock.setPosition(((StatementBlock) closeBlock).getConditionPlugPosition());\n                ((StatementBlock) closeBlock).addConditionBlock((ConditionBlock) draggedBlock);\n            } else {\n                closeBlock = getConditionBlockConditionPlugWithinRadius(draggedBlock, radius);\n                if (closeBlock != null) {\n                    draggedBlock.setPosition(((HorizontallyConnectable) closeBlock).getPlugPosition());\n                    StatementBlock parent = (StatementBlock) closeBlock.getParentBlock();\n                    parent.addConditionBlock((ConditionBlock) draggedBlock);\n                }\n            }\n        }\n    }\n\n    /**\n     * @return Returns the next to be executed block of the program. This methods does not return the effectively\n     * to be executed block, but the next block of the program stack !\n     */\n    public Block getNextProgramBlock() {\n        return nextProgramBlock;\n    }\n\n    /**\n     * Sets the next block to the next block in the list, otherwise to null.\n     */\n    public void setNextProgramBlock() {\n        if (!getNextProgramBlock().isBusy()) {\n            int i = program.indexOf(nextProgramBlock);\n            if (i + 1 < program.size()) {\n                nextProgramBlock = program.get(i + 1);\n            } else {\n                nextProgramBlock = null;\n            }\n        }\n    }\n\n    public void setNextProgramBlock(Block block) {\n        this.nextProgramBlock = block;\n    }\n\n    /**\n     * @return returns the block at the given position (x,y) if that block exists otherwise null will be returned.\n     */\n    public Block getBlockAt(int x, int y) {\n        Optional<Block> found = getAllBlocks().stream().filter(block1 -> block1.isPositionOn(x, y)).findAny();\n        System.out.println(found);\n        return found.orElse(null);\n    }\n\n    /**\n     * @param draggedBlock block that is dragged\n     * @param closeBlock   closest block to the dragged block\n     * @return Returns the connection point if precondition is valid\n     * @pre Both blocks are close enough to each other for connection\n     */\n    private Point getVerticalConnectionPoint(Block draggedBlock, Block closeBlock) {\n        if (!(draggedBlock instanceof VerticallyConnectable && closeBlock instanceof VerticallyConnectable))\n            throw new IllegalArgumentException(\"Not both blocks are vertically connectable\");\n\n        if (draggedBlock.isUnder(closeBlock)) return ((VerticallyConnectable) closeBlock).getPlugPosition();\n        else\n            return new Point(((VerticallyConnectable) closeBlock).getSocketPosition().x,\n                    ((VerticallyConnectable) closeBlock).getSocketPosition().y - draggedBlock.getHeight() - 10);\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the block with plug that is within the given radius of the given block\n     */\n    private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block) continue;\n\n            if (b instanceof HorizontallyConnectable && block instanceof HorizontallyConnectable) {\n                if (getDistance(((HorizontallyConnectable) block).getSocketPosition(), ((HorizontallyConnectable) b).getPlugPosition()) <= radius) {\n                    return b;\n                }\n            } else if (b instanceof VerticallyConnectable && block instanceof VerticallyConnectable) {\n                if (getDistance(((VerticallyConnectable) block).getSocketPosition(), ((VerticallyConnectable) b).getPlugPosition()) <= radius) {\n                    return b;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the block with socket within the given radius of the given block\n     */\n    private Block getBlockWithSocketForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block) continue;\n\n            if (b instanceof HorizontallyConnectable && block instanceof HorizontallyConnectable) {\n                if (getDistance(((HorizontallyConnectable) block).getPlugPosition(), ((HorizontallyConnectable) b).getSocketPosition()) <= radius) {\n                    return b;\n                }\n            } else if (b instanceof VerticallyConnectable && block instanceof VerticallyConnectable) {\n                if (getDistance(((VerticallyConnectable) block).getPlugPosition(), ((VerticallyConnectable) b).getSocketPosition()) <= radius) {\n                    return b;\n                }\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block body plug within the given radius of the given block\n     */\n    private Block getBlockWithBodyPlugWithinRadius(Block block, int radius) {\n        if (!(block instanceof VerticallyConnectable))\n            throw new IllegalArgumentException(\"Block is not vertically connectable\");\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof BlockWithBody) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)\n                continue;\n\n            if (getDistance(((VerticallyConnectable) block).getSocketPosition(), ((BlockWithBody) b).getBodyPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the statement block condition plug within the given radius of the given block\n     */\n    private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {\n        if (!(block instanceof HorizontallyConnectable))\n            throw new IllegalArgumentException(\"Block is not horizontally connectable\");\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())\n                continue;\n\n            if (getDistance(((HorizontallyConnectable) block).getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param block  given block\n     * @param radius given radius\n     * @return Returns the condition block condition plug within the given radius of the given block\n     */\n    private Block getConditionBlockConditionPlugWithinRadius(Block block, int radius) {\n        if (!(block instanceof ConditionBlock)) throw new IllegalArgumentException();\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof ConditionBlock))\n                continue;\n\n            if (getDistance(((ConditionBlock) block).getSocketPosition(), ((ConditionBlock) b).getPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list after the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockAfter(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock) + 1);\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list before the given existing block (if not null).\n     *\n     * @param block         given block\n     * @param existingBlock given existing block in program\n     */\n    private void addProgramBlockBefore(Block block, Block existingBlock) {\n        assert program.contains(existingBlock);\n        insertProgramBlockAtIndex(block, program.indexOf(existingBlock));\n    }\n\n    private void insertProgramBlockAtIndex(Block block, int index) {\n        program.add(index, block);\n        int distance = block.getHeight() + block.getStep();\n        if (block instanceof StatementBlock) distance += ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index + 1, distance);\n    }\n\n    /**\n     * @param block given block\n     *              Remove the given block from the program of this program area.\n     *              This does not mean that the given block is removed or outside the PA.\n     * @pre getProgram().contains(block)\n     */\n    private void removeProgramBlock(Block block) {\n        assert getProgram().contains(block);\n        int index = program.indexOf(block);\n        program.remove(block);\n\n        int distance = -block.getHeight() - block.getStep();\n        if (block instanceof StatementBlock) distance -= ((StatementBlock) block).getGapSize();\n        PushBlocks.pushFrom(program, index, distance);\n        getProgram().remove(block);\n        allBlocks.remove(block);\n    }\n\n    /**\n     * Remove the clickedBlock from this program area\n     *\n     * @param clickedBlock block that's dragged\n     */\n    public void removeBlockFromPA(Block clickedBlock) {\n        if (!(clickedBlock instanceof ConditionBlock)) {\n            BlockWithBody parentBlock = clickedBlock.getParentBlock();\n            if (parentBlock != null) {\n                pushUpBodyAndProgramAfterClickOn(parentBlock, clickedBlock);\n            }\n            // fixes bug without problems like line 385\n            if (getProgram().size() == 0 && getAllBlocks().size() > 0){\n                setNextProgramBlock(getMostUpperBlock());\n                if (getNextProgramBlock() != null) {\n                    program.add(getNextProgramBlock());\n                }\n            }\n            // TODO: remove this!\n//            else {\n//                setNextProgramBlock(getMostUpperBlock());\n//                if (getNextProgramBlock() != null) {\n//                    program.add(getNextProgramBlock());\n//                }\n//            }\n        } else if (clickedBlock.getParentBlock() != null) {\n            ((StatementBlock) clickedBlock.getParentBlock()).removeConditionBlock((ConditionBlock) clickedBlock);\n        }\n        allBlocks.remove(clickedBlock);\n        if (getProgram().contains(clickedBlock)) {\n            removeProgramBlock(clickedBlock);\n        }\n    }\n\n    private Block getMostUpperBlock() {\n        Optional<Block> min = getAllBlocks().stream().filter(block -> !(block instanceof ConditionBlock)).min(Comparator.comparingInt(block -> (int) block.getPosition().getY()));\n        return min.orElse(null);\n    }\n\n    /**\n     * Push up the body of the given parentBlock and the program due to a click on the given clicked block.\n     *\n     * @param clickedBlock\n     * @param parentBlock\n     */\n    private void pushUpBodyAndProgramAfterClickOn(BlockWithBody parentBlock, Block clickedBlock) {\n        // 1) Remove the body and push all superior body-blocks up\n        parentBlock.removeBodyBlock(clickedBlock);\n        // 2) Push program up\n        if (parentBlock instanceof FunctionDefinitionBlock) return;\n        // 2.1) Find most superior program block\n        while (parentBlock.getParentBlock() != null) {\n            parentBlock = parentBlock.getParentBlock();\n        }\n        // 2.2) Push\n        if (getProgram().contains(parentBlock)) {\n            int distance = -clickedBlock.getHeight() - clickedBlock.getStep();\n            if (clickedBlock instanceof StatementBlock)\n                distance -= ((StatementBlock) clickedBlock).getGapSize();\n            PushBlocks.pushFrom(program, program.indexOf(parentBlock) + 1, distance);\n        }\n    }\n\n    /**\n     * Resets the program area, first block will be current block.\n     */\n    public void resetProgramExecution() {\n        for (Block block : getAllBlocks()) if (block instanceof BlockWithBody) ((BlockWithBody) block).resetExecution();\n        if (!program.isEmpty()) nextProgramBlock = ((LinkedList<Block>) program).getFirst();\n    }\n\n\n    public void restore(List<Block> allBlocks, List<Block> program, Block nextProgramBlock){\n        this.allBlocks.clear();\n        this.allBlocks.addAll(allBlocks);\n        this.program.clear();\n        this.program.addAll(program);\n        setNextProgramBlock(nextProgramBlock);\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/ProgramArea.java	(revision dc27b89a48302f811c653c6329fd327593f1b1b4)
+++ code-backend/src/main/java/com/swop/ProgramArea.java	(date 1590320815083)
@@ -178,6 +178,15 @@
             int i = program.indexOf(nextProgramBlock);
             if (i + 1 < program.size()) {
                 nextProgramBlock = program.get(i + 1);
+                // TODO: Fix whole method(s) and call it setNextBlock (not programblock)
+//                if (nextProgramBlock instanceof StatementBlock) {
+//                    if (((StatementBlock) nextProgramBlock).isConditionValid() && ((StatementBlock) nextProgramBlock).getBodyBlocks().size() > 0) {
+//
+//                        nextProgramBlock = ((StatementBlock) nextProgramBlock).getBodyBlocks().get(0);
+//                    }
+//                } else if (nextProgramBlock) {
+//
+//                }
             } else {
                 nextProgramBlock = null;
             }
Index: code-backend/src/main/java/com/swop/BlockrGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.Block;\nimport com.swop.blocks.BlockWithBody;\nimport com.swop.command.*;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class BlockrGame {\n    private final ProgramArea programArea;\n    private final GameWorldType gameWorldType;\n    /**\n     * Maximum number of blocks that can be used\n     */\n    private final int maxBlocks;\n    private GameWorld gameWorld;\n    /**\n     * Stack for all the undo's\n     */\n    private final Stack<ICommand> undoStack = new Stack<>();\n    /**\n     * Stack for all the redo's\n     */\n    private final Stack<ICommand> redoStack = new Stack<>();\n\n    /**\n     * Initializes BlockrGame\n     *\n     * @param maxBlocks     maximum number of blocks that can be used.\n     * @param gameWorldType given type of gameWorld\n     */\n    public BlockrGame(int maxBlocks, GameWorldType gameWorldType) {\n        this.maxBlocks = maxBlocks;\n        this.programArea = new ProgramArea();\n        this.gameWorldType = gameWorldType;\n        this.gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns program that is currently in program area\n     */\n    public List<Block> getProgram() {\n        return programArea.getProgram();\n    }\n\n    public ProgramArea getProgramArea() {\n        return programArea;\n    }\n\n    /**\n     * @param block Given block\n     * @return Returns the position of the given block\n     */\n    public Point getBlockPosition(Block block) {\n        return block.getPosition();\n    }\n\n    /**\n     * Adds block to Program Area\n     *\n     * @param block given block\n     */\n    public void dropBlockInPAAt(Block block, int x, int y) {\n        if (block == null) throw new IllegalArgumentException();\n        executeCommand(new DropBlockCommand(programArea, block, x, y));\n    }\n\n    /**\n     * Removes block from Program Area\n     *\n     * @param draggedBlock given block\n     * @param isRelease    Boolean recording whether this is a release (outside PA) or not (a click)\n     */\n    public void removeBlockFromPA(Block draggedBlock, boolean isRelease) {\n        if (isRelease) {\n            executeCommand(new DeleteBlockCommand(programArea, draggedBlock));\n        } else {\n            programArea.removeBlockFromPA(draggedBlock);\n        }\n    }\n\n    /**\n     * Executes next block\n     */\n    public void executeNext() {\n        if (programArea.getNextProgramBlock() != null) {\n            executeCommand(new ExecuteCommand(this, programArea.getNextProgramBlock()));\n        } else {\n            executeCommand(new ResetCommand(this));\n        }\n    }\n\n    public Block getNextToBeExecutedBlock() {\n        if (programArea.getNextProgramBlock() instanceof BlockWithBody) {\n            BlockWithBody blockWithBody = (BlockWithBody) programArea.getNextProgramBlock();\n\n            if (blockWithBody.getNextBodyBlock() != null) {\n                return blockWithBody.getNextBodyBlock();\n            }\n        }\n        // TODO: else if statement call block .. OR refactor\n        return programArea.getNextProgramBlock();\n    }\n\n    /**\n     * Resets the game world and the program area\n     */\n    public void resetEverything() {\n        programArea.resetProgramExecution();\n        gameWorld = gameWorldType.createNewInstance();\n    }\n\n    /**\n     * @return Returns the number of blocks that are in the Program Area\n     */\n    public int getNumBlocksInPA() {\n        return programArea.getAllBlocks().size();\n    }\n\n    public int getNumBlocksInProgram() {\n        int count = 0;\n        for (Block block : getProgram()) {\n            count += block.getCount();\n        }\n        return count;\n    }\n\n    /**\n     * @return Returns all the blocks that are in the Program Area\n     */\n    public List<Block> getAllBlocksInPA() {\n        return programArea.getAllBlocks();\n    }\n\n    /**\n     * position of a block is (x,y)\n     *\n     * @param x x-value of position\n     * @param y y-value of position\n     * @return returns a block if there is one at the given position otherwise null will be returned.\n     */\n    public Block getBlockInPaAt(int x, int y) {\n        return programArea.getBlockAt(x, y);\n    }\n\n    /**\n     * @return Returns true if the number of blocks in the program area is equal or greater than the maximum number of blocks\n     */\n    public boolean isPaletteHidden() {\n        return (maxBlocks - getNumBlocksInPA()) <= 0;\n    }\n\n    /**\n     * @return Returns the game world\n     */\n    public GameWorld getGameWorld() {\n        return gameWorld;\n    }\n\n    /**\n     * @return Returns the game world type\n     */\n    public GameWorldType getGameWorldType() {\n        return gameWorldType;\n    }\n\n    /**\n     * undoes the previous operation if there is one otherwise nothing will be done\n     */\n    public void undoCommand() {\n        if (!undoStack.isEmpty()) {\n            ICommand command = undoStack.pop();\n            command.undo();\n            redoStack.add(command);\n        }\n    }\n\n    /**\n     * redoes the previous undone operation if an operation is undone otherwise nothing happens\n     */\n    public void redoCommand() {\n        if (!redoStack.isEmpty()) {\n            executeCommand(redoStack.pop());\n        }\n    }\n\n    /**\n     * Given command will be executed\n     *\n     * @param command given command\n     */\n    public void executeCommand(ICommand command) {\n        command.execute();\n        undoStack.add(command);\n        if (command instanceof DeleteBlockCommand || command instanceof DropBlockCommand) resetEverything();\n    }\n\n    public void reset()\n    {\n        executeCommand(new ResetCommand(this));\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-backend/src/main/java/com/swop/BlockrGame.java	(revision dc27b89a48302f811c653c6329fd327593f1b1b4)
+++ code-backend/src/main/java/com/swop/BlockrGame.java	(date 1590320700337)
@@ -93,6 +93,7 @@
     }
 
     public Block getNextToBeExecutedBlock() {
+        // TODO: remove whole if clause after fix in ProgramArea
         if (programArea.getNextProgramBlock() instanceof BlockWithBody) {
             BlockWithBody blockWithBody = (BlockWithBody) programArea.getNextProgramBlock();
 
