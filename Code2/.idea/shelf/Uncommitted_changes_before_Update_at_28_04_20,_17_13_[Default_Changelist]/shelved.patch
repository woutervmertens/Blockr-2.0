Index: code-frontend/src/main/java/com/swop/MyCanvasWindow.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.swop;\n\nimport com.swop.blocks.Block;\nimport com.swop.handlers.DisplaceBlockHandler;\nimport com.swop.handlers.ExecuteProgramHandler;\nimport com.swop.uiElements.BlockTypes;\nimport com.swop.uiElements.UIBlock;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MyCanvasWindow extends CanvasWindow {\n    // Handlers\n    BlockrGame blockrGame;\n    DisplaceBlockHandler displaceBlockHandler;\n    ExecuteProgramHandler executeProgramHandler;\n    //KeyHolds\n    boolean isHoldingCtrl = false;\n    boolean isHoldingShift = false;\n    private boolean isPaletteHidden = false;\n    // Variables\n    private UIBlock draggedBlock;\n    private Point pos = new Point(0, 0);\n    private final int maxBlocks = 10;\n\n    /**\n     * Initializes a CanvasWindow object.\n     *\n     * @param title Window title\n     */\n    protected MyCanvasWindow(String title, GameWorldType gameWorldType) {\n        super(title);\n        blockrGame = BlockrGame.createInstance(maxBlocks, gameWorldType);\n        // Make blockUIMap and share the REFERENCE to all handlers who need it\n        Map<Block, UIBlock> blockUIBlockMap = new HashMap<>();\n        displaceBlockHandler = new DisplaceBlockHandler(blockrGame, blockUIBlockMap);\n        executeProgramHandler = new ExecuteProgramHandler(blockrGame, blockUIBlockMap);\n    }\n\n    @Override\n    protected void paint(Graphics g) {\n        isPaletteHidden = blockrGame.isPaletteHidden();\n        Windows.drawWindows(g, isPaletteHidden, displaceBlockHandler.getAllUIBlocksInPA(), blockrGame.getGameWorld());\n\n        if (draggedBlock != null) {\n            g.setColor(draggedBlock.getColor());\n            g.fillPolygon(draggedBlock.getPolygon());\n            g.setColor(Color.BLACK);\n            g.drawString(draggedBlock.getText(), draggedBlock.getTextPosition().x, draggedBlock.getTextPosition().y);\n        }\n        g.setColor(Color.BLACK);\n        g.drawString(\"# blocks available: \" + (maxBlocks - executeProgramHandler.getNumBlocksInPA()), width - 140, height - 10);\n    }\n\n    /**\n     * Calls the respective handlers for each supported mouse input.\n     *\n     * @param id         The MouseEvent id.\n     * @param x          The x position of the mouse action.\n     * @param y          The y position of the mouse action.\n     * @param clickCount The number of clicks associated with this event.\n     */\n    @Override\n    protected void handleMouseEvent(int id, int x, int y, int clickCount) {\n        super.handleMouseEvent(id, x, y, clickCount);\n        switch (id) {\n            case MouseEvent.MOUSE_PRESSED:\n                draggedBlock = getUIBlock(x, y);\n                if (Windows.PROGRAM_AREA.isWithin(x, y) && draggedBlock != null) {\n                    displaceBlockHandler.handleProgramAreaForClickOn(draggedBlock);\n                }\n                break;\n            case MouseEvent.MOUSE_CLICKED:\n                break;\n            case MouseEvent.MOUSE_DRAGGED:\n                if (isBlockDragged()) {\n                    pos.x = x;\n                    pos.y = y;\n                    draggedBlock.setPosition((Point) pos.clone());\n                    repaint();\n                }\n                break;\n            case MouseEvent.MOUSE_RELEASED:\n                if (isBlockDragged()) {\n                    if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n                        displaceBlockHandler.handleReleaseInPA(draggedBlock);\n                    } else {\n                        displaceBlockHandler.handleReleaseOutsidePA(draggedBlock);\n                    }\n                    draggedBlock = null;\n                    repaint();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected mouse event: \" + id);\n        }\n        displaceBlockHandler.adjustAllBlockPositions();\n        displaceBlockHandler.adjustAllStatementBlockGaps();\n        executeProgramHandler.reset();\n        // TODO: executeProgramHandler.getCorrespondingUiBlockFor(blockrGame.getCurrentActiveBlock()).setHighlightStateOn(true);\n    }\n\n\n    /**\n     * Returns the UIBlock at the given click coordinates\n     *\n     * @param x Given x of click\n     * @param y Given y of click\n     * @return The UIBlock at the given coordinates or null\n     */\n    private UIBlock getUIBlock(int x, int y) {\n        if (Windows.PALETTE.isWithin(x, y) && !isPaletteHidden) {\n            BlockTypes type = Windows.getTypeOfClick(x, y);\n            return type.getNewUIBlock(x, y);\n        } else if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n            return displaceBlockHandler.getCorrespondingUiBlockFor(blockrGame.getBlockInPaAt(x, y));\n        }\n        return null;\n    }\n\n    /**\n     * Calls the respective handlers for each supported key input.\n     *\n     * @param id      The KeyEvent id (Pressed or typed).\n     * @param keyCode The numerical value of the key.\n     * @param keyChar The char value of the key.\n     */\n    @Override\n    protected void handleKeyEvent(int id, int keyCode, char keyChar) {\n        super.handleKeyEvent(id, keyCode, keyChar);\n        boolean bRepaint = false;\n        if (id == KeyEvent.KEY_PRESSED) {\n            switch (keyCode) {\n                case 116: //F5\n                    executeNext();\n                    bRepaint = true;\n                    break;\n                case 27: //Escape\n                    resetProgramExecution();\n                    bRepaint = true;\n                    break;\n                case 90: //Z\n                    if (isHoldingCtrl) {\n                        if (isHoldingShift) redo();\n                        else undo();\n                        isHoldingShift = false;\n                        isHoldingCtrl = false;\n                        bRepaint = true;\n                    }\n            }\n\n            if (keyCode == 17) isHoldingCtrl = true;\n            if (keyCode == 16) isHoldingShift = true;\n\n            System.out.println(\"Ctrl \" + isHoldingCtrl);\n            System.out.println(\"Shift \" + isHoldingShift);\n\n            if (bRepaint) repaint();\n        }\n\n        displaceBlockHandler.adjustAllBlockPositions();\n        displaceBlockHandler.adjustAllStatementBlockGaps();\n        // TODO: executeProgramHandler.getCorrespondingUiBlockFor(blockrGame.getCurrentActiveBlock()).setHighlightStateOn(true);\n    }\n\n    private void executeNext() {\n        executeProgramHandler.executeNext();\n    }\n\n    private void undo() {\n        executeProgramHandler.undo();\n    }\n\n    private void redo() {\n        executeProgramHandler.redo();\n    }\n\n    private void resetProgramExecution() {\n        executeProgramHandler.reset();\n    }\n\n    /**\n     * Checks whether at this moment a block is being dragged.\n     */\n    private boolean isBlockDragged() {\n        return draggedBlock != null;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(revision dc04e34838592b8c449c4ada1b514d171a23f5e8)
+++ code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(date 1587734447717)
@@ -100,7 +100,10 @@
         displaceBlockHandler.adjustAllBlockPositions();
         displaceBlockHandler.adjustAllStatementBlockGaps();
         executeProgramHandler.reset();
-        // TODO: executeProgramHandler.getCorrespondingUiBlockFor(blockrGame.getCurrentActiveBlock()).setHighlightStateOn(true);
+//        try {
+//            executeProgramHandler.getCorrespondingUiBlockFor(blockrGame.getCurrentActiveBlock()).setHighlightStateOn(true);
+//        } catch (NullPointerException ignored) {
+//        }
     }
 
 
@@ -163,7 +166,6 @@
 
         displaceBlockHandler.adjustAllBlockPositions();
         displaceBlockHandler.adjustAllStatementBlockGaps();
-        // TODO: executeProgramHandler.getCorrespondingUiBlockFor(blockrGame.getCurrentActiveBlock()).setHighlightStateOn(true);
     }
 
     private void executeNext() {
Index: .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20,_21_33_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20,_21_33_[Default_Changelist]/shelved.patch	(revision dc04e34838592b8c449c4ada1b514d171a23f5e8)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20,_21_33_[Default_Changelist]/shelved.patch	(revision dc04e34838592b8c449c4ada1b514d171a23f5e8)
@@ -1,156 +0,0 @@
-Index: code-frontend/src/main/java/com/swop/MyCanvasWindow.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.swop;\n\nimport com.swop.blocks.StatementBlock;\nimport com.swop.handlers.DisplaceBlockHandler;\nimport com.swop.handlers.ExecuteProgramHandler;\nimport com.swop.uiElements.BlockTypes;\nimport com.swop.uiElements.UIBlock;\nimport com.swop.uiElements.UIStatementBlock;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\n\npublic class MyCanvasWindow extends CanvasWindow {\n    private boolean isPaletteHidden = false;\n    // Variables\n    private UIBlock draggedBlock;\n    private Point pos = new Point(0, 0);\n    private int maxBlocks = 10;\n    // Handlers\n    BlockrGame blockrGame;\n    DisplaceBlockHandler displaceBlockHandler;\n    ExecuteProgramHandler executeProgramHandler;\n\n    /**\n     * Initializes a CanvasWindow object.\n     *\n     * @param title Window title\n     */\n    protected MyCanvasWindow(String title, GameWorldType gameWorldType) {\n        super(title);\n        blockrGame = new BlockrGame(maxBlocks,gameWorldType);\n        displaceBlockHandler = new DisplaceBlockHandler(blockrGame);\n        executeProgramHandler = new ExecuteProgramHandler(blockrGame);\n    }\n\n    @Override\n    protected void paint(Graphics g) {\n        isPaletteHidden = blockrGame.isPaletteHidden();\n        Windows.drawWindows(g, isPaletteHidden, displaceBlockHandler.getAllUIBlocksInPA(),blockrGame.getGameWorld());\n\n        if (draggedBlock != null) {\n            g.setColor(draggedBlock.getColor());\n            g.fillPolygon(draggedBlock.getPolygon());\n            g.setColor(Color.BLACK);\n            g.drawString(draggedBlock.getText(), draggedBlock.getTextPosition().x, draggedBlock.getTextPosition().y);\n        }\n        g.setColor(Color.BLACK);\n        g.drawString(\"# blocks available: \" + (maxBlocks - executeProgramHandler.getNumBlocksInPA()), width - 140, height - 10);\n    }\n\n    /**\n     * Calls the respective handlers for each supported mouse input.\n     *\n     * @param id         The MouseEvent id.\n     * @param x          The x position of the mouse action.\n     * @param y          The y position of the mouse action.\n     * @param clickCount The number of clicks associated with this event.\n     */\n    @Override\n    protected void handleMouseEvent(int id, int x, int y, int clickCount) {\n        super.handleMouseEvent(id, x, y, clickCount);\n        switch (id) {\n            case MouseEvent.MOUSE_PRESSED:\n                executeProgramHandler.reset();\n                draggedBlock = getUIBlock(x, y);\n                if (Windows.PROGRAM_AREA.isWithin(x,y) && draggedBlock != null) {\n                    displaceBlockHandler.handleProgramAreaForClickOn(draggedBlock);\n                }\n                break;\n            case MouseEvent.MOUSE_CLICKED:\n                break;\n            case MouseEvent.MOUSE_DRAGGED:\n                if (isBlockDragged()) {\n                    pos.x = x;\n                    pos.y = y;\n                    int dx = x - draggedBlock.getPosition().x;\n                    int dy = y - draggedBlock.getPosition().y;\n                    draggedBlock.setPosition((Point) pos.clone());\n                    if (draggedBlock instanceof UIStatementBlock && draggedBlock.getCorrespondingBlock() != null) {\n                        displaceBlockHandler.displaceAllBodyBlocksOfWith((UIStatementBlock)draggedBlock, dx, dy);\n                    }\n\n                    repaint();\n                }\n                break;\n            case MouseEvent.MOUSE_RELEASED:\n                if (isBlockDragged()) {\n                    if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n                        displaceBlockHandler.handleReleaseInPA(draggedBlock);\n                    } else {\n                        displaceBlockHandler.handleReleaseOutsidePA(draggedBlock);\n                    }\n                    draggedBlock = null;\n                    repaint();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected mouse event: \" + id);\n        }\n    }\n\n    /**\n     * Returns the UIBlock at the given click coordinates\n     *\n     * @param x Given x of click\n     * @param y Given y of click\n     * @return The UIBlock at the given coordinates or null\n     */\n    private UIBlock getUIBlock(int x, int y) {\n        if (Windows.PALETTE.isWithin(x, y) && !isPaletteHidden) {\n            BlockTypes type = Windows.getTypeOfClick(x, y);\n            return type.getNewUIBlock(x, y);\n        } else if (Windows.PROGRAM_AREA.isWithin(x, y)) {\n            // TODO: check\n            return displaceBlockHandler.getCorrespondingUiBlockFor(blockrGame.getBlockInPaAt(x, y));\n        }\n        return null;\n    }\n\n    /**\n     * Calls the respective handlers for each supported key input.\n     *\n     * @param id      The KeyEvent id (Pressed or typed).\n     * @param keyCode The numerical value of the key.\n     * @param keyChar The char value of the key.\n     */\n    @Override\n    protected void handleKeyEvent(int id, int keyCode, char keyChar) {\n        super.handleKeyEvent(id, keyCode, keyChar);\n        if (id == KeyEvent.KEY_PRESSED) {\n            switch (keyCode) {\n                case 116: //F5\n                    executeNext();\n                    repaint();  // TODO: highlight UI ?\n                    break;\n                case 27: //Escape\n                    resetProgramExecution();\n                    repaint();\n                    break;\n            }\n        }\n    }\n\n    private void executeNext() {\n        executeProgramHandler.executeNext();\n    }\n\n    private void resetProgramExecution() {\n        executeProgramHandler.reset();\n    }\n\n    /**\n     * Checks whether at this moment a block is being dragged.\n     */\n    private boolean isBlockDragged() {\n        return draggedBlock != null;\n    }\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(revision 47b7587d8a3207a2d106c50bf1970860a81584e2)
-+++ code-frontend/src/main/java/com/swop/MyCanvasWindow.java	(date 1586607330663)
-@@ -1,6 +1,5 @@
- package com.swop;
- 
--import com.swop.blocks.StatementBlock;
- import com.swop.handlers.DisplaceBlockHandler;
- import com.swop.handlers.ExecuteProgramHandler;
- import com.swop.uiElements.BlockTypes;
-@@ -72,13 +71,11 @@
-                 break;
-             case MouseEvent.MOUSE_DRAGGED:
-                 if (isBlockDragged()) {
--                    pos.x = x;
--                    pos.y = y;
--                    int dx = x - draggedBlock.getPosition().x;
--                    int dy = y - draggedBlock.getPosition().y;
-+                    int dx = pos.x - draggedBlock.getPosition().x;
-+                    int dy = pos.y - draggedBlock.getPosition().y;
-                     draggedBlock.setPosition((Point) pos.clone());
-                     if (draggedBlock instanceof UIStatementBlock && draggedBlock.getCorrespondingBlock() != null) {
--                        displaceBlockHandler.displaceAllBodyBlocksOfWith((UIStatementBlock)draggedBlock, dx, dy);
-+                        displaceBlockHandler.displaceAllBodyBlocksAndConditionsOfBlockWithDistance((UIStatementBlock)draggedBlock, dx, dy);
-                     }
- 
-                     repaint();
-Index: code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.swop.handlers;\n\nimport com.swop.BlockrGame;\nimport com.swop.PushBlocks;\nimport com.swop.blocks.Block;\nimport com.swop.blocks.StatementBlock;\nimport com.swop.uiElements.UIBlock;\nimport com.swop.uiElements.UIConditionBlock;\nimport com.swop.uiElements.UIStatementBlock;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class DisplaceBlockHandler {\n    /**\n     * Map with as keys all the backend blocks present in the PA and their corresponding ui block as value.\n     */\n    private Map<Block, UIBlock> blockUIBlockMap = new HashMap<>();\n\n    private Map<Block, UIBlock> getBlockUIBlockMap() {\n        return blockUIBlockMap;\n    }\n\n    public void putInBlockUIBlockMap(Block key, UIBlock value) {\n        blockUIBlockMap.put(key, value);\n    }\n\n    public UIBlock getCorrespondingUiBlockFor(Block block) {\n        try {\n            return blockUIBlockMap.get(block);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    public DisplaceBlockHandler(BlockrGame blockrGame) {\n        this.blockrGame = blockrGame;\n    }\n\n    /**\n     * Connection with backend\n     */\n    private BlockrGame blockrGame;\n\n    /**\n     * @pre draggedBlock.getPosition() is inside the PA\n     */\n    public void handleReleaseInPA(UIBlock draggedBlock) {\n        if (draggedBlock.getCorrespondingBlock() == null)\n            draggedBlock.makeNewCorrespondingBlockIn(blockrGame.getGameWorld());\n\n        Block backendBlock = draggedBlock.getCorrespondingBlock();\n        if (!getBlockUIBlockMap().containsKey(backendBlock)) {\n            putInBlockUIBlockMap(backendBlock, draggedBlock);\n        }\n        blockrGame.dropBlockInPA(backendBlock);\n        draggedBlock.setPosition(blockrGame.getBlockPosition(backendBlock));\n\n        adjustAllStatementBlockGaps();\n        adjustAllBlockPositions();\n    }\n\n    private void adjustAllStatementBlockGaps() {\n        for (Block block : blockrGame.getAllBlocksInPA()) {\n            if (block instanceof StatementBlock) {\n                UIStatementBlock uiStatement = (UIStatementBlock) getCorrespondingUiBlockFor(block);\n                uiStatement.setGapSize(((StatementBlock) block).getGapSize());\n            }\n        }\n    }\n\n    private void adjustAllBlockPositions() {\n        for (Block block : blockrGame.getAllBlocksInPA()) {\n            UIBlock uiBlock = getCorrespondingUiBlockFor(block);\n            uiBlock.setPosition(block.getPosition());\n        }\n    }\n\n    public void handleReleaseOutsidePA(UIBlock draggedBlock) {\n        if (draggedBlock.getCorrespondingBlock() != null) {\n            if (draggedBlock.getCorrespondingBlock() instanceof StatementBlock) {\n                for (Block bodyBlock: ((StatementBlock)draggedBlock.getCorrespondingBlock()).getBodyBlocks()) {\n                    blockUIBlockMap.remove(bodyBlock);\n                    blockrGame.removeBlockFromPA(bodyBlock);\n                }\n            }\n            //remove from the map in DisplaceBlockHandler\n            blockUIBlockMap.remove(draggedBlock.getCorrespondingBlock());\n            //remove the block from program area\n            blockrGame.removeBlockFromPA(draggedBlock.getCorrespondingBlock());\n\n        }\n        draggedBlock.terminate();\n    }\n\n    public List<UIBlock> getAllUIBlocksInPA() {\n        List<Block> backBlocks = blockrGame.getAllBlocksInPA();\n        List<UIBlock> returnUIBlocks = new ArrayList<>();\n        for (Block block : backBlocks) {\n            returnUIBlocks.add(getCorrespondingUiBlockFor(block));\n        }\n        return returnUIBlocks;\n    }\n\n    public void handleProgramAreaForClickOn(UIBlock clickedBlock) {\n        if (clickedBlock == null) throw new IllegalArgumentException();\n\n        if (!(clickedBlock instanceof UIConditionBlock)) {\n            StatementBlock parentStatement = clickedBlock.getCorrespondingBlock().getParentStatement();\n            if (parentStatement != null) {\n                PushBlocks.pushBodyBlocksOfSuperiorParents(clickedBlock.getCorrespondingBlock().getParentStatement().getBodyBlocks(),\n                        -clickedBlock.getHeight() - clickedBlock.getStep());\n                parentStatement.removeBodyBlock(clickedBlock.getCorrespondingBlock());\n            }\n\n            if (clickedBlock instanceof UIStatementBlock && !((StatementBlock) (clickedBlock.getCorrespondingBlock())).getBodyBlocks().isEmpty()) {\n                // TODO: don't remove all body blocks but just handle program and gaps changes\n                //((StatementBlock) clickedBlock.getCorrespondingBlock()).removeAllBodyBlocks();\n\n            }\n        } else {\n            // TODO:\n        }\n        // TODO: check if the program contains that block ? Is it needed ?\n        blockrGame.removeProgramBlock(clickedBlock.getCorrespondingBlock());\n\n        adjustAllBlockPositions();\n        adjustAllStatementBlockGaps();\n    }\n\n    public void displaceAllBodyBlocksOfWith(UIStatementBlock draggedBlock, int dx, int dy) {\n        for (Block bodyBlock : ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks()) {\n            bodyBlock.setPosition(new Point(bodyBlock.getPosition().x + dx, bodyBlock.getPosition().y + dy));\n            if (bodyBlock instanceof StatementBlock) {\n                for (Block bodyBlock2: ((StatementBlock) bodyBlock).getBodyBlocks()) {\n                    bodyBlock2.setPosition(new Point(bodyBlock2.getPosition().x + dx, bodyBlock2.getPosition().y + dy));\n                }\n            }\n        }\n        adjustAllBlockPositions();\n    }\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(revision 47b7587d8a3207a2d106c50bf1970860a81584e2)
-+++ code-frontend/src/main/java/com/swop/handlers/DisplaceBlockHandler.java	(date 1586606932382)
-@@ -3,6 +3,7 @@
- import com.swop.BlockrGame;
- import com.swop.PushBlocks;
- import com.swop.blocks.Block;
-+import com.swop.blocks.ConditionBlock;
- import com.swop.blocks.StatementBlock;
- import com.swop.uiElements.UIBlock;
- import com.swop.uiElements.UIConditionBlock;
-@@ -82,7 +83,7 @@
-     public void handleReleaseOutsidePA(UIBlock draggedBlock) {
-         if (draggedBlock.getCorrespondingBlock() != null) {
-             if (draggedBlock.getCorrespondingBlock() instanceof StatementBlock) {
--                for (Block bodyBlock: ((StatementBlock)draggedBlock.getCorrespondingBlock()).getBodyBlocks()) {
-+                for (Block bodyBlock : ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks()) {
-                     blockUIBlockMap.remove(bodyBlock);
-                     blockrGame.removeBlockFromPA(bodyBlock);
-                 }
-@@ -131,11 +132,16 @@
-         adjustAllStatementBlockGaps();
-     }
- 
--    public void displaceAllBodyBlocksOfWith(UIStatementBlock draggedBlock, int dx, int dy) {
--        for (Block bodyBlock : ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks()) {
--            bodyBlock.setPosition(new Point(bodyBlock.getPosition().x + dx, bodyBlock.getPosition().y + dy));
--            if (bodyBlock instanceof StatementBlock) {
--                for (Block bodyBlock2: ((StatementBlock) bodyBlock).getBodyBlocks()) {
-+    public void displaceAllBodyBlocksAndConditionsOfBlockWithDistance(UIStatementBlock draggedBlock, int dx, int dy) {
-+        // Body blocks
-+        List<Block> bodyAndConditionBlocks = ((StatementBlock) draggedBlock.getCorrespondingBlock()).getBodyBlocks();
-+        // Adding conditions
-+        bodyAndConditionBlocks.addAll(((StatementBlock) draggedBlock.getCorrespondingBlock()).getConditions());
-+
-+        for (Block block :bodyAndConditionBlocks) {
-+            block.setPosition(new Point(block.getPosition().x + dx, block.getPosition().y + dy));
-+            if (block instanceof StatementBlock) {
-+                for (Block bodyBlock2 : ((StatementBlock) block).getBodyBlocks()) {
-                     bodyBlock2.setPosition(new Point(bodyBlock2.getPosition().x + dx, bodyBlock2.getPosition().y + dy));
-                 }
-             }
-Index: code-backend/src/main/java/com/swop/ProgramArea.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package com.swop;\n\nimport com.swop.blocks.*;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.*;\n\n/**\n * A program area that handles drops of blocks in it for constructing program(s).\n * It has no notion of position or width or height.\n */\npublic class ProgramArea implements PushBlocks {\n    private final int radius = 15;  // Radius for connections\n    /**\n     * List recording all the blocks that belong to the current program of this program area WITHOUT nested blocks.\n     * Nested blocks (inside StatementBlocks) should be accessed using ''\n     */\n    private List<Block> program = new LinkedList<>();\n    /**\n     * Array recording all blocks currently present in program area\n     */\n    private List<Block> allBlocks = new ArrayList<>();\n    private Block currentBlock;\n\n    public List<Block> getAllBlocks() {\n        return allBlocks;\n    }\n\n    public List<Block> getProgram() {\n        return program;\n    }\n\n    /**\n     * @pre the position of the block is inside the ui program area.\n     */\n    public void dropBlock(Block draggedBlock) {\n        Point pos = draggedBlock.getPosition();\n        draggedBlock.setPosition(pos);\n        if (!allBlocks.contains(draggedBlock)) allBlocks.add(draggedBlock);\n        if (allBlocks.size() == 1) {\n            program.add(draggedBlock);\n            return;\n        }\n\n        // TODO: add eventually correctly to program !!!\n\n        // 1) Find close block and type\n        Block closeBlock = null;\n        int type;\n        if (!(draggedBlock instanceof ConditionBlock)) {\n            // 1) plug\n            closeBlock = getBlockWithPlugForBlockWithinRadius(draggedBlock, radius);\n            type = 1;\n            if (closeBlock == null) {\n                // 2) socket\n                closeBlock = getBlockWithSocketForBlockWithinRadius(draggedBlock, radius);\n                type = 2;\n                if (closeBlock == null) {\n                    // 3) statement body\n                    closeBlock = getStatementBlockBodyPlugWithinRadius(draggedBlock, radius);\n                    type = 3;\n                }\n            }\n        } else {\n            // 4) statement condition\n            closeBlock = getStatementBlockConditionPlugWithinRadius(draggedBlock, radius);\n            type = 4;\n        }\n\n        // 2) Find connection point and add to program/body\n        Point connectionPoint = null;\n        if (closeBlock != null) {\n            switch (type) {\n                case 1: //Plug\n                    if (program.contains(closeBlock)) {\n                        program.add(program.indexOf(closeBlock) + 1, draggedBlock);\n                        PushBlocks.pushBlocksInListFromIndexWithDistance(program, program.indexOf(draggedBlock) + 1,\n                                draggedBlock.getHeight() + draggedBlock.getStep());\n                    } if (closeBlock.getParentStatement() != null) {\n                        closeBlock.getParentStatement().addBodyBlockAfter(draggedBlock, closeBlock);\n                        PushBlocks.pushBodyBlocksOfSuperiorParents(draggedBlock.getParentStatement().getBodyBlocks(),\n                                draggedBlock.getHeight() + draggedBlock.getStep());\n                    }\n                    connectionPoint = getConnectionPoint(draggedBlock, closeBlock);\n                    break;\n                case 2: //Socket\n                    if (program.contains(closeBlock)) {\n                        program.add(program.indexOf(closeBlock), draggedBlock);\n                        PushBlocks.pushBlocksInListFromIndexWithDistance(program, program.indexOf(draggedBlock) + 1,\n                                draggedBlock.getHeight() + draggedBlock.getStep());\n                    } if (closeBlock.getParentStatement() != null) {\n                        closeBlock.getParentStatement().addBodyBlockBefore(draggedBlock, closeBlock);\n                        PushBlocks.pushBodyBlocksOfSuperiorParents(draggedBlock.getParentStatement().getBodyBlocks(),\n                                draggedBlock.getHeight() + draggedBlock.getStep());\n                    }\n                    connectionPoint = getConnectionPoint(draggedBlock, closeBlock);\n                    break;\n                case 3: //Statement body\n                    connectionPoint = ((StatementBlock) closeBlock).getBodyPlugPosition();\n                    ((StatementBlock) closeBlock).addBodyBlockAfter(draggedBlock, null);\n                    PushBlocks.pushBodyBlocksOfSuperiorParents(draggedBlock.getParentStatement().getBodyBlocks(),\n                            draggedBlock.getHeight() + draggedBlock.getStep());\n                    break;\n                case 4: //Statement condition\n                    connectionPoint = ((StatementBlock) closeBlock).getConditionPlugPosition();\n                    ((StatementBlock) closeBlock).addConditionBlock((ConditionBlock) draggedBlock);\n                    break;\n            }\n            System.out.println(\"Close block: \" + closeBlock);\n            if (draggedBlock instanceof StatementBlock) {\n                // Connect this statementblock and adjust all its body blocks positions\n                int dx = connectionPoint.x - draggedBlock.getPosition().x;\n                int dy = connectionPoint.y - draggedBlock.getPosition().y;\n                draggedBlock.setPosition(connectionPoint);\n                for (Block bodyBlock : ((StatementBlock) draggedBlock).getBodyBlocks()) {\n                    bodyBlock.setPosition(new Point(bodyBlock.getPosition().x + dx, bodyBlock.getPosition().y + dy));\n                }\n            } else {\n                draggedBlock.setPosition(connectionPoint);\n            }\n            // TODO:\n//            if (draggedBlock.getParentStatement() != null) {\n//                ((UIStatementBlock) draggedBlock.getParentStatement()).increaseGapSize(draggedBlock.getHeight() + 5);\n//            }\n        } else {\n            // TODO: should this else block still exist ??\n\n//            //TODO: create new program in backend\n//            draggedBlock.setPosition(dropPos);\n//            //Backend add block to current blockgroup\n//            executeProgramHandler.addBlockToProgramArea(draggedBlock, null);\n        }\n//        uiProgramArea.addBlock(draggedBlock);\n\n        // TODO: Reset the execution of the program bcs a new block was added\n\n    }\n\n    public Block getCurrentBlock() {\n        return currentBlock;\n    }\n\n    private void setCurrentBlock(Block first) {\n        this.currentBlock = first;\n    }\n\n    public Block getBlockAt(int x, int y) {\n        Optional<Block> found = getAllBlocks().stream().filter(block1 -> block1.isPositionOn(x, y)).findAny();\n        System.out.println(found);\n        return found.orElse(null);\n    }\n\n    /**\n     * Get the distance between two given points.\n     *\n     * @param b Point1\n     * @param p Point2\n     */\n    private static int getDistance(Point b, Point p) {\n        return (int) Math.sqrt((p.getX() - b.getX()) * (p.getX() - b.getX()) + (p.getY() - b.getY()) * (p.getY() - b.getY()));\n    }\n\n    /**\n     * @pre Both blocks are close enough to each other for connection !\n     */\n    public Point getConnectionPoint(Block draggedBlock, Block closeBlock) {\n        if (draggedBlock.isUnder(closeBlock)) return closeBlock.getPlugPosition();\n        else\n            return new Point(closeBlock.getSocketPosition().x, closeBlock.getSocketPosition().y - draggedBlock.getHeight() - 10);\n    }\n\n    private Block getBlockWithPlugForBlockWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || (block instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (block instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            // TODO: maybe type cast with interfaces\n            if (getDistance(block.getSocketPosition(), b.getPlugPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    private Block getBlockWithSocketForBlockWithinRadius(Block uiBlock, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == uiBlock || (uiBlock instanceof HorizontallyConnectable && !(b instanceof HorizontallyConnectable))\n                    || (uiBlock instanceof VerticallyConnectable && !(b instanceof VerticallyConnectable)))\n                continue;\n\n            // TODO: maybe type cast with interfaces\n            if (getDistance(uiBlock.getPlugPosition(), b.getSocketPosition()) <= radius) {\n                return b;\n            }\n\n        }\n        return null;\n    }\n\n    // TODO: connect to last body block fix\n    private Block getStatementBlockBodyPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) /*|| !((StatementBlock) b).getBodyBlocks().isEmpty()*/)\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getBodyPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    // TODO: connect to last condition of the conditions of statement (add getConditionPlugWithinRadius() )\n    private Block getStatementBlockConditionPlugWithinRadius(Block block, int radius) {\n        for (Block b : getAllBlocks()) {\n            if (b == block || !(b instanceof StatementBlock) || !((StatementBlock) b).getConditions().isEmpty())\n                continue;\n\n            if (getDistance(block.getSocketPosition(), ((StatementBlock) b).getConditionPlugPosition()) <= radius) {\n                return b;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add given block to the program of this program area and\n     * insert it in the program list after the given existing block (if not null).\n     */\n    public void addProgramBlockAfter(Block block, Block existingBlock) {\n        program.add(program.indexOf(existingBlock) + 1, block);\n        for (int i = program.indexOf(existingBlock) + 1; i < program.size(); i++) {\n            Block currentBlock = program.get(i);\n            currentBlock.setPosition(new Point(currentBlock.getPosition().x, currentBlock.getPosition().y + block.getHeight() + block.getStep()));\n        }\n        // TODO: finish\n\n    }\n\n    /**\n     * Remove the given block from the program of this program area.\n     * This does not mean that the given block is removed or outside the PA.\n     *\n     * @pre getProgram().contains(block)\n     */\n    public void removeProgramBlock(Block block) {\n        assert getProgram().contains(block);\n\n        // TODO: Correct method\n//        PushBlocks.pushBlocksInListFromIndexWithDistance(getProgram(), getProgram().indexOf(block) + 1,\n//                -block.getHeight() - block.getStep());\n//        PushBlocks.pushBodyBlocksOfSuperiorParents(getProgram(), -block.getHeight() - block.getStep());\n\n        getProgram().remove(block);\n\n//        if (index > 0) {\n//            for (int i = index; i < getProgram().size(); i++) {\n//                Block currentBlock = getProgram().get(i);\n//                currentBlock.setPosition(new Point(currentBlock.getPosition().x,\n//                        currentBlock.getPosition().y - block.getHeight()));\n//            }\n//        }\n    }\n\n    /**\n     * Remove the draggedBlock from allBlocks of the program area\n     */\n    public void removeBlockFromPA(Block draggedBlock) {\n        allBlocks.remove(draggedBlock);\n        draggedBlock.terminate();\n    }\n\n    public void executeNext() {\n        // TODO execute(gameworld)\n    }\n\n    public void reset() {\n        try {\n            setCurrentBlock(((LinkedList<Block>) program).getFirst());\n        } catch (NoSuchElementException ignore) {\n        }\n    }\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- code-backend/src/main/java/com/swop/ProgramArea.java	(revision 47b7587d8a3207a2d106c50bf1970860a81584e2)
-+++ code-backend/src/main/java/com/swop/ProgramArea.java	(date 1586603630525)
-@@ -77,7 +77,8 @@
-                         program.add(program.indexOf(closeBlock) + 1, draggedBlock);
-                         PushBlocks.pushBlocksInListFromIndexWithDistance(program, program.indexOf(draggedBlock) + 1,
-                                 draggedBlock.getHeight() + draggedBlock.getStep());
--                    } if (closeBlock.getParentStatement() != null) {
-+                    }
-+                    if (closeBlock.getParentStatement() != null) {
-                         closeBlock.getParentStatement().addBodyBlockAfter(draggedBlock, closeBlock);
-                         PushBlocks.pushBodyBlocksOfSuperiorParents(draggedBlock.getParentStatement().getBodyBlocks(),
-                                 draggedBlock.getHeight() + draggedBlock.getStep());
-@@ -89,7 +90,8 @@
-                         program.add(program.indexOf(closeBlock), draggedBlock);
-                         PushBlocks.pushBlocksInListFromIndexWithDistance(program, program.indexOf(draggedBlock) + 1,
-                                 draggedBlock.getHeight() + draggedBlock.getStep());
--                    } if (closeBlock.getParentStatement() != null) {
-+                    }
-+                    if (closeBlock.getParentStatement() != null) {
-                         closeBlock.getParentStatement().addBodyBlockBefore(draggedBlock, closeBlock);
-                         PushBlocks.pushBodyBlocksOfSuperiorParents(draggedBlock.getParentStatement().getBodyBlocks(),
-                                 draggedBlock.getHeight() + draggedBlock.getStep());
-Index: .idea/jarRepositories.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- .idea/jarRepositories.xml	(date 1586603148116)
-+++ .idea/jarRepositories.xml	(date 1586603148116)
-@@ -0,0 +1,20 @@
-+<?xml version="1.0" encoding="UTF-8"?>
-+<project version="4">
-+  <component name="RemoteRepositoriesConfiguration">
-+    <remote-repository>
-+      <option name="id" value="central" />
-+      <option name="name" value="Central Repository" />
-+      <option name="url" value="https://repo.maven.apache.org/maven2" />
-+    </remote-repository>
-+    <remote-repository>
-+      <option name="id" value="central" />
-+      <option name="name" value="Maven Central repository" />
-+      <option name="url" value="https://repo1.maven.org/maven2" />
-+    </remote-repository>
-+    <remote-repository>
-+      <option name="id" value="jboss.community" />
-+      <option name="name" value="JBoss Community repository" />
-+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
-+    </remote-repository>
-+  </component>
-+</project>
-\ No newline at end of file
-Index: .idea/libraries/gameworldapi.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><component name=\"libraryTable\">\n  <library name=\"gameworldapi\">\n    <CLASSES>\n      <root url=\"jar://$PROJECT_DIR$/../worlds/gameworldapi.jar!/\" />\n    </CLASSES>\n    <JAVADOC />\n    <SOURCES />\n  </library>\n</component>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- .idea/libraries/gameworldapi.xml	(revision 47b7587d8a3207a2d106c50bf1970860a81584e2)
-+++ .idea/libraries/gameworldapi.xml	(date 1586604276719)
-@@ -2,6 +2,7 @@
-   <library name="gameworldapi">
-     <CLASSES>
-       <root url="jar://$PROJECT_DIR$/../worlds/gameworldapi.jar!/" />
-+      <root url="jar://$PROJECT_DIR$/../worlds/robotgame.jar!/" />
-     </CLASSES>
-     <JAVADOC />
-     <SOURCES />
Index: .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20__21_33__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20__21_33__Default_Changelist_.xml	(revision dc04e34838592b8c449c4ada1b514d171a23f5e8)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_18_04_20__21_33__Default_Changelist_.xml	(revision dc04e34838592b8c449c4ada1b514d171a23f5e8)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_18_04_20,_21_33_[Default_Changelist]" date="1587238428837" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_18_04_20,_21_33_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 18.04.20, 21:33 [Default Changelist]" />
-</changelist>
\ No newline at end of file
